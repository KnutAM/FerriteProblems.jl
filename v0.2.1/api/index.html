<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FerriteProblems.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteProblems.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FerriteProblems.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Main-types"><span>Main types</span></a></li><li><a class="tocitem" href="#Convergence-criteria"><span>Convergence criteria</span></a></li><li><a class="tocitem" href="#Access-functions"><span>Access functions</span></a></li><li><a class="tocitem" href="#Saving-and-loading-data"><span>Saving and loading data</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="../examples/io/">IO: Saving and loading simulations</a></li><li><a class="tocitem" href="../examples/transient_heat/">Linear Time Dependent Problem</a></li><li><a class="tocitem" href="../examples/incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../examples/porous_media/">Porous media</a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The main types below are exported.  Remaining functions are not exported to avoid polluting the  name space. <em>Tip:</em> To simplify calling the following functions it is possible to write <code>import FerriteProblems as FP</code> as is done in the examples. </p><h2 id="Main-types"><a class="docs-heading-anchor" href="#Main-types">Main types</a><a id="Main-types-1"></a><a class="docs-heading-anchor-permalink" href="#Main-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.FerriteProblem" href="#FerriteProblems.FerriteProblem"><code>FerriteProblems.FerriteProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FerriteProblem(def::FEDefinition, post=nothing, io=nothing)</code></pre><p>Create a FerriteProblem from <a href="#FerriteProblems.FEDefinition"><code>def</code></a>. Postprocessing can be added as <code>post</code>, see <a href="#FESolvers.postprocess!"><code>FESolvers.postprocess!</code></a>. File input/output using <code>FerriteIO</code> can be added with <code>io</code>.  It is possible to give the folder where to save the output (i.e. io::String),  or to construct <a href="#FerriteProblems.FerriteIO"><code>FerriteIO</code></a> with more options directly.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.FEDefinition" href="#FerriteProblems.FEDefinition"><code>FerriteProblems.FEDefinition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create the <code>FEDefinition</code> which can later be used to create a complete  <code>FerriteProblem</code>. </p><pre><code class="nohighlight hljs">FEDefinition(;dh, ch, material, cellvalues, 
    nh=NeumannHandler(dh),
    convergence_criterion=AbsoluteResidual(), 
    initial_conditions=NamedTuple(),
    user_data=nothing, 
    autodiffbuffer=Val(false), threading=Val(false)
    )</code></pre><p>This first definition sets up a <strong>single domain</strong> simulation  (same <code>material</code>, <code>cellvalues</code>, interpolations, etc. everywhere). </p><pre><code class="nohighlight hljs">FEDefinition(domains::Vector{&lt;:AssemblyDomain}}; ch, 
    nh=NeumannHandler(dh),
    convergence_criterion=AbsoluteResidual(), 
    initial_conditions=NamedTuple(), 
    autodiffbuffer=Val(false), threading=Val(false)
    )</code></pre><p>This second definition sets up a <strong>multi-domain</strong> simulation by using <code>FerriteAssembly.jl</code>&#39;s <code>AssemblyDomain</code>.  The <code>dh</code> used for the default NeumannHandler is extracted from <code>domains</code>. </p><p><strong>Common inputs</strong></p><p>For both constructors cases, the following inputs can be supplied</p><ul><li><code>ch</code>: The constraint handler, <code>ConstraintHandler</code> (<code>Ferrite.jl</code>)</li><li><code>nh</code>: The neumann bc handler, <code>NeumannHandler</code> (<code>FerriteNeumann.jl</code>)</li><li><code>initial_conditions</code>: NamedTuple with a function <code>f(x)</code> for each field that has a nonzero  initial condition. Used by the <code>Ferrite.jl</code>&#39;s <code>apply_analytical!</code> function. Example: <code>initial_conditions = (u = x -&gt; Vec((x[1]/10, 0.0)), p = x -&gt; -100*x[2])</code>.  For fields not given here, the initial condition is zeros everywhere.  </li><li><code>convergence_criterion</code>: Determines how to calculate the convergence measure including scaling. See <a href="#FerriteProblems.ConvergenceCriterion"><code>ConvergenceCriterion</code></a></li><li><code>autodiffbuffer</code>: Should <code>FerriteAssembly.jl</code>&#39;s <code>AutoDiffCellBuffer</code> be used?  This will make the assembly faster if automatic differentiation is used, and can also be used  without automatic differentiation (but with a slight extra computational overhead) <code>Bool</code> input can also be given (will be converted internally to <code>Val</code>)</li><li><code>threading</code>: Should threading be used?  <code>Bool</code> input can also be given (will be converted internally to <code>Val</code>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.FerriteIO" href="#FerriteProblems.FerriteIO"><code>FerriteProblems.FerriteIO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FerriteIO(
    folder::String, def::FEDefinition, post=nothing; 
    def_file=&quot;FEDefinition.jld2&quot;, 
    postfile=&quot;FEPost.jld2&quot;,
    T=Float64, 
    nsteps_per_file=typemax(Int), 
    switchsize=Inf
    )</code></pre><p>Constructor for creating a <code>FerriteIO</code> when simulating. </p></div></section><section><div><pre><code class="nohighlight hljs">FerriteIO(filename::String)</code></pre><p>Constructor for reading a <code>FerriteIO</code> that was saved during a simulation</p></div></section></article><h2 id="Convergence-criteria"><a class="docs-heading-anchor" href="#Convergence-criteria">Convergence criteria</a><a id="Convergence-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-criteria" title="Permalink"></a></h2><p>In normal usage, the following convergence criteria can be used</p><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.ConvergenceCriterion" href="#FerriteProblems.ConvergenceCriterion"><code>FerriteProblems.ConvergenceCriterion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceCriterion</code></pre><p>The abstract type <code>ConvergenceCriterion</code> is the supertype for all  convergence criteria. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.AbsoluteResidual" href="#FerriteProblems.AbsoluteResidual"><code>FerriteProblems.AbsoluteResidual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsoluteResidual()</code></pre><p>The default convergence criterion that calculates the convergence measure as  <code>√(sum([r[i]^2 for i ∈ free dofs])</code> without any scaling. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.RelativeResidualElementScaling" href="#FerriteProblems.RelativeResidualElementScaling"><code>FerriteProblems.RelativeResidualElementScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeResidualElementScaling(p, minfactors::Union{AbstractFloat,NamedTuple}=eps())</code></pre><p>Use <code>Ferriteassembly.ElementResidualScaling</code> with the exponent <code>p</code> to calculate the  scaling for each field individually, based on the L2-norm of each cell&#39;s residual.  To avoid issues when all cells have zero residual (e.g. in the first time step), supply <code>minfactors</code> as the minimum scaling factor.  The convergence measure is calculated with the following pseudo-code</p><pre><code class="language-julia hljs">val = 0.0
for field in Ferrite.getfieldnames(dh)
    factor = max(element_residual_scaling[field], minfactors[field])
    dofs = free_field_dofs[field]   # Get the non-constrained dofs for `field`
    val += sum(i-&gt;(r[i]/factor)^2, dofs)
end
return √val</code></pre><p>where the same <code>minfactor</code> is used for all fields if only a scalar value is given. </p></div></section></article><p>To create custom convergence criteria, the following functions  may require overloading. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.TolScaling" href="#FerriteProblems.TolScaling"><code>FerriteProblems.TolScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TolScaling(criterion::ConvergenceCriterion, def::FEDefinition)</code></pre><p>The <code>TolScaling</code> type contains the <code>criterion</code> that determines how to scale the residuals to determine  convergence. The constructor is specialized on <code>typeof(criterion)</code>, creating the following fields:</p><ul><li><code>assemscaling</code>: <code>scaling</code> to be used by <code>FerriteAssembly</code> to give potential scaling contribution based on each element&#39;s residual</li><li><code>buffer</code>: Used to pre-calculate values, such as dof-ranges for each field that is used when calculating the convergence measure. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FESolvers.calculate_convergence_measure" href="#FESolvers.calculate_convergence_measure"><code>FESolvers.calculate_convergence_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FESolvers.calculate_convergence_measure(::ConvergenceCriterion, scaling::TolScaling, r::Vector, Δa, iter, p::FerriteProblem)</code></pre><p>Specialize this function for each <code>ConvergenceCriterion</code>. Note this function is called via the definition</p><pre><code class="nohighlight hljs">calculate_convergence_measure(ts::TolScaling, args...) = calculate_convergence_measure(ts.criterion, ts, args...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.make_assemscaling" href="#FerriteProblems.make_assemscaling"><code>FerriteProblems.make_assemscaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_assemscaling(criterion, def)</code></pre><p>Create the <code>scaling</code> for use in <code>FerriteAssembly</code> if required by the given <code>criterion</code>. The default, if not overloaded, returns <code>nothing</code>. </p></div></section></article><h2 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getdh" href="#FerriteProblems.getdh"><code>FerriteProblems.getdh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getdh(p::FerriteProblem)</code></pre><p>Get <code>dh::Ferrite.AbstractDofHandler</code> from the <code>FerriteProblem</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getch" href="#FerriteProblems.getch"><code>FerriteProblems.getch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getch(p::FerriteProblem)</code></pre><p>Get the <code>ConstraintHandler</code> from the <code>FerriteProblem</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getnh" href="#FerriteProblems.getnh"><code>FerriteProblems.getnh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getnh(p::FerriteProblem)</code></pre><p>Get the <code>NeumannHandler</code> from the <code>FerriteProblem</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_material" href="#FerriteAssembly.get_material"><code>FerriteAssembly.get_material</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.get_material(p::FerriteProblem)
FerriteProblems.get_material(p::FerriteProblem, domain_name::String)</code></pre><p>Get the material in <code>p</code>. For multiple domains, it is necessary to give the <code>domain_name</code> for where to get the material. Note that this is type-unstable and should be avoided in  performance-critical code sections. This function belongs to <code>FerriteAssembly.jl</code>,  but can be accessed via <code>FerriteProblems.get_material</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FESolvers.getjacobian" href="#FESolvers.getjacobian"><code>FESolvers.getjacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getjacobian(p::FerriteProblem)</code></pre><p>Get the current jacobian matrix from <code>p</code>.  Note that this function belongs to <code>FESolvers.jl</code>, but can be accessed via <code>FerriteProblems.getjacobian</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FESolvers.getunknowns" href="#FESolvers.getunknowns"><code>FESolvers.getunknowns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getunknowns(p::FerriteProblem)</code></pre><p>Get the current vector of unknowns from <code>p</code>.  Note that this function belongs to <code>FESolvers.jl</code>, but can be accessed via <code>FerriteProblems.getunknowns</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FESolvers.getresidual" href="#FESolvers.getresidual"><code>FESolvers.getresidual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getresidual(p::FerriteProblem)</code></pre><p>Get the current residual vector from <code>p</code>.  Note that this function belongs to <code>FESolvers.jl</code>, but can be accessed via <code>FerriteProblems.getresidual</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getneumannforce" href="#FerriteProblems.getneumannforce"><code>FerriteProblems.getneumannforce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getneumannforce(p::FerriteProblem)</code></pre><p>Get the current external force vector caused by  Neumann boundary conditions. Note that this vector  does not include external forces added during the  cell assembly; only forces added with the <code>NeumannHandler</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getoldunknowns" href="#FerriteProblems.getoldunknowns"><code>FerriteProblems.getoldunknowns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getoldunknowns(p::FerriteProblem)</code></pre><p>Get the vector of unknowns from the previously converged step</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getstate" href="#FerriteProblems.getstate"><code>FerriteProblems.getstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getstate(p::FerriteProblem)</code></pre><p>Get the current state variables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getoldstate" href="#FerriteProblems.getoldstate"><code>FerriteProblems.getoldstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getoldstate(p::FerriteProblem)</code></pre><p>Get the state variables from the previously converged step</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.gettime" href="#FerriteProblems.gettime"><code>FerriteProblems.gettime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.gettime(p::FerriteProblem)</code></pre><p>Get the current time</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getoldtime" href="#FerriteProblems.getoldtime"><code>FerriteProblems.getoldtime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getoldtime(p::FerriteProblem)</code></pre><p>Get time of the previous converged step</p></div></section></article><h2 id="Saving-and-loading-data"><a class="docs-heading-anchor" href="#Saving-and-loading-data">Saving and loading data</a><a id="Saving-and-loading-data-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FESolvers.postprocess!" href="#FESolvers.postprocess!"><code>FESolvers.postprocess!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FESolvers.postprocess!(p::FerriteProblem, step, solver)</code></pre><p>When <code>FESolvers</code> call this function for <code>p::FerriteProblem</code>,  the following function</p><pre><code class="nohighlight hljs">FESolvers.postprocess!(post, p::FerriteProblem, step, solver)</code></pre><p>is called where <code>post=p.post</code> (unless you define a different override).  This allows you to easily define the dispatch on your postprocessing  type as <code>FESolvers.postprocess!(post::MyPostType, p, step, solver)</code> Note that the <code>solver</code> input argument is required, but can be  accounted for by defining, e.g.  <code>FESolvers.postprocess!(post::MyPostType, p, step, args...)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.close_postprocessing" href="#FerriteProblems.close_postprocessing"><code>FerriteProblems.close_postprocessing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">close_postprocessing(post::MyPostType, p::FerriteProblem)</code></pre><p>This function is called to close any open files manually created during  the postprocessing with the custom postprocessing type <code>MyPostType</code>.  Note that the file streams in p.io::FerriteIO are  automatically closed and don&#39;t require any special handling.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.addstep!" href="#FerriteProblems.addstep!"><code>FerriteProblems.addstep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.addstep!(io::FerriteIO, p::FerriteProblem)</code></pre><p>Add a new step to be saved by <code>io</code> at the time <code>gettime(p)</code> Must be called before adding any new data</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.gettimedata" href="#FerriteProblems.gettimedata"><code>FerriteProblems.gettimedata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gettimedata(io::FerriteIO)
gettimedata(io::FerriteIO, step)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.savedofdata!" href="#FerriteProblems.savedofdata!"><code>FerriteProblems.savedofdata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.savedofdata!(io::FerriteIO, vals, dt_order=0, field=&quot;dof&quot;)</code></pre><p>Save data pertaining to each degree of freedom. Use a different field than <code>&quot;dof&quot;</code>` to save data located at each dof,  but not the actual dof values (e.g. the residual vector)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getdofdata" href="#FerriteProblems.getdofdata"><code>FerriteProblems.getdofdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getdofdata(io::FerriteIO, step, field=&quot;dof&quot;; dt_order=0)</code></pre><p>Get the data saved by <a href="#FerriteProblems.savedofdata!"><code>FerriteProblems.savedofdata!</code></a> in <code>step</code> for <code>field</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.savenodedata!" href="#FerriteProblems.savenodedata!"><code>FerriteProblems.savenodedata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.savenodedata!(io::FerriteIO, vals, field, dt_order=0)</code></pre><p>Save data located at each node. By convention this should be indexed by the node numbers in the grid. (E.g. a <code>Vector</code> for all nodes or a <code>Dict{Int}</code> with keys the node numbers)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getnodedata" href="#FerriteProblems.getnodedata"><code>FerriteProblems.getnodedata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getnodedata(io::FerriteIO, step, field; dt_order=0)</code></pre><p>Get the data saved by <a href="#FerriteProblems.savenodedata!"><code>FerriteProblems.savenodedata!</code></a> in <code>step</code> for <code>field</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.savecelldata!" href="#FerriteProblems.savecelldata!"><code>FerriteProblems.savecelldata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.savecelldata!(io::FerriteIO, vals, field, dt_order=0)</code></pre><p>Save data for each cell.  By convention this should be indexed by the cell numbers in the grid. (E.g. a <code>Vector</code> for all cells or a <code>Dict{Int}</code> with keys the cell indices)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getcelldata" href="#FerriteProblems.getcelldata"><code>FerriteProblems.getcelldata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getcelldata(io::FerriteIO, step, field; dt_order=0)</code></pre><p>Get the data saved by <a href="#FerriteProblems.savecelldata!"><code>FerriteProblems.savecelldata!</code></a> in <code>step</code> for <code>field</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.saveipdata!" href="#FerriteProblems.saveipdata!"><code>FerriteProblems.saveipdata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.saveipdata!(io::FerriteIO, vals, field, dt_order=0)</code></pre><p>Save data for each integration point in cells in the grid.  By convention the data for each cell should be indexed by the cell numbers in the grid. (E.g. a <code>Vector</code> for all cells or a <code>Dict{Int}</code> with keys the cell indices) Note that it is on the user to know how the integration points are numbered,  i.e. which <code>QuadratureRule</code> that was used. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getipdata" href="#FerriteProblems.getipdata"><code>FerriteProblems.getipdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getipdata(io::FerriteIO, step, field; dt_order=0)</code></pre><p>Get the data saved by <a href="#FerriteProblems.saveipdata!"><code>FerriteProblems.saveipdata!</code></a> in <code>step</code> for <code>field</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.saveglobaldata!" href="#FerriteProblems.saveglobaldata!"><code>FerriteProblems.saveglobaldata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.saveglobaldata!(io::FerriteIO, vals, field, dt_order=0)</code></pre><p>Save data that is global to the entire simulation, i.e. global quantites such as  reaction forces, total dissipation, etc. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getglobaldata" href="#FerriteProblems.getglobaldata"><code>FerriteProblems.getglobaldata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getglobaldata(io::FerriteIO, step, field; dt_order=0)</code></pre><p>Get the data saved by <a href="#FerriteProblems.saveglobaldata!"><code>FerriteProblems.saveglobaldata!</code></a> in <code>step</code> for <code>field</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getdef" href="#FerriteProblems.getdef"><code>FerriteProblems.getdef</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getdef(io::FerriteIO)</code></pre><p>Load the <code>FEDefinition</code> from the results saved by <code>io</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteProblems.getpost" href="#FerriteProblems.getpost"><code>FerriteProblems.getpost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteProblems.getpost(io::FerriteIO)</code></pre><p>Load the user defined <code>post</code> from the results saved by <code>io</code></p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/plasticity/">Plasticity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 14 May 2023 16:00">Sunday 14 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
