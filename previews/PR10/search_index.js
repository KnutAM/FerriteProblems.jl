var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"../literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This example is the adoption of Ferrite.jls example To adapt, we make a few changes, specifically that we don't use BlockArrays","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The full code, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA","category":"page"},{"location":"examples/incompressible_elasticity/#Problem-setup","page":"Incompressible Elasticity","title":"Problem setup","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Define a cache for the material, as used in the original example","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function FerriteAssembly.allocate_cell_cache(::LinearElasticity, cv::NamedTuple)\n    cellvalues_u = cv[:u]\n    return collect([symmetric(shape_gradient(cellvalues_u, 1, i)) for i in 1:getnbasefunctions(cellvalues_u)])\nend\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), Returns(zero(Vec{2}))))\n    close!(ch)\n    update!(ch, 0.0)\n\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    lh = LoadHandler(dh)\n    add!(lh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    domainspec = DomainSpec(dh, m, cv)\n    return FEDefinition(domainspec; ch, lh)\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Physics-(element-routine)","page":"Incompressible Elasticity","title":"Physics (element routine)","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We define the element according to FerriteAssembly, and without any Neumann contributions. We restrict this element to only work with FESolvers.LinearProblemSolver by not including the internal forces in residual. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n\n    # Get the local indices for each field\n    udofs = dof_range(buffer, :u)\n    pdofs = dof_range(buffer, :p)\n\n    # Extract cached gradients\n    ∇Nu_sym_dev = FA.get_user_cache(buffer)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:length(udofs)\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for (i_u, i) in enumerate(udofs)\n            for (j_u, j) in enumerate(udofs[1:i_u])\n                Ke[i,j] += 2 * mp.G * ∇Nu_sym_dev[i_u] ⊡ ∇Nu_sym_dev[j_u] * dΩ\n            end\n        end\n\n        for (i_p, i) in enumerate(pdofs)\n            δNp = shape_value(cellvalues_p, q_point, i_p)\n            for (j_u, j) in enumerate(udofs)\n                divδNu = shape_divergence(cellvalues_u, q_point, j_u)\n                Ke[i,j] += -δNp * divδNu * dΩ\n            end\n            for (j_p, j) in enumerate(pdofs[1:i_p])\n                Np = shape_value(cellvalues_p, q_point, j_p)\n                Ke[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Postprocessing","page":"Incompressible Elasticity","title":"Postprocessing","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct IE_PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::IE_PostProcessing, p, step, solver)\n    step == 1 && return nothing # We don't want to save the initial conditions.\n    dh = FP.get_dofhandler(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Solving-the-problem","page":"Incompressible Elasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = IE_PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(p1, solver)\nsolve_problem!(p2, solver)","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Here follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend\n\nfunction FerriteAssembly.allocate_cell_cache(::LinearElasticity, cv::NamedTuple)\n    cellvalues_u = cv[:u]\n    return collect([symmetric(shape_gradient(cellvalues_u, 1, i)) for i in 1:getnbasefunctions(cellvalues_u)])\nend\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), Returns(zero(Vec{2}))))\n    close!(ch)\n    update!(ch, 0.0)\n\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    lh = LoadHandler(dh)\n    add!(lh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    domainspec = DomainSpec(dh, m, cv)\n    return FEDefinition(domainspec; ch, lh)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n\n    # Get the local indices for each field\n    udofs = dof_range(buffer, :u)\n    pdofs = dof_range(buffer, :p)\n\n    # Extract cached gradients\n    ∇Nu_sym_dev = FA.get_user_cache(buffer)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:length(udofs)\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for (i_u, i) in enumerate(udofs)\n            for (j_u, j) in enumerate(udofs[1:i_u])\n                Ke[i,j] += 2 * mp.G * ∇Nu_sym_dev[i_u] ⊡ ∇Nu_sym_dev[j_u] * dΩ\n            end\n        end\n\n        for (i_p, i) in enumerate(pdofs)\n            δNp = shape_value(cellvalues_p, q_point, i_p)\n            for (j_u, j) in enumerate(udofs)\n                divδNu = shape_divergence(cellvalues_u, q_point, j_u)\n                Ke[i,j] += -δNp * divδNu * dΩ\n            end\n            for (j_p, j) in enumerate(pdofs[1:i_p])\n                Np = shape_value(cellvalues_p, q_point, j_p)\n                Ke[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nstruct IE_PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::IE_PostProcessing, p, step, solver)\n    step == 1 && return nothing # We don't want to save the initial conditions.\n    dh = FP.get_dofhandler(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\n\nfunction build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = IE_PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(p1, solver)\nsolve_problem!(p2, solver)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"../literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file. We have modified the names and functions to comply with MaterialModelsBase.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This file defines the","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"J2Plasticity<:AbstractMaterial material type with the constructor J2Plasticity(E,ν,σy0,H)\nState variable struct J2PlasticityMaterialState<:AbstractMaterialState\nThe MaterialModelsBase function initial_material_state and material_response","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Support for a single material according to the MaterialModelsBase interface is supported directly by FerriteAssembly.jl","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition. To be able to save the results using JLD2, we cannot use anonymous functions, so a struct for the ramping is created instead:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct VectorRamp{dim,T}<:Function\n    ramp::Vec{dim,T}\nend\n(vr::VectorRamp)(x, t, n) = t*vr.ramp\nconst traction_function = VectorRamp(Vec(0.0, 0.0, 1.e7))\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # CellValues\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}())\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zero(Vec{3})), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    lh = LoadHandler(dh)\n    quad_order = 3\n    add!(lh, Neumann(:u, quad_order, getfaceset(grid, \"right\"), traction_function))\n\n    domainspec = DomainSpec(dh, material, cv)\n    return FEDefinition(domainspec; ch, lh)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, FerriteAssembly.element_routine! is defined in FerriteAssembly.jl.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. Note that, internally, FerriteProblems imports the FESolvers functions getunknowns, getjacobian, and getresidual, such that you can access these via FerriteProblems. (or FP. if using the import FerriteProblems as FP above). For convenience, FerriteProblems will call FESolvers.postprocess! with the post as the first argument making it easy to dispatch on:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(zero(Vec{3}), FP.get_time(p), zero(Vec{3}))[3])\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.get_state(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We also define a helper function to plot the results after completion","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(post::PlasticityPostProcess;\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    plot!(plt, post.umag, post.tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results. Here, we use FerriteProblems' safesolve that (1) creates our full problem::FerriteProblem and (2) ensures that files are closed even when the problem doesn't converge.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"global umax_solution = [0.0] # To save result for test #hide\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem.post, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"fixed\", markershape=:circle)\n    umax_solution[1] = problem.post.umag[end] # Save value for comparison  #hide\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\nusing Test # Compare to Ferrite.jl's example #hide\n@test isapprox(umax_solution[1], 0.254452; rtol=1.e-4);  #hide\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr();\n\ninclude(\"J2Plasticity.jl\");\n\nstruct VectorRamp{dim,T}<:Function\n    ramp::Vec{dim,T}\nend\n(vr::VectorRamp)(x, t, n) = t*vr.ramp\nconst traction_function = VectorRamp(Vec(0.0, 0.0, 1.e7))\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # CellValues\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}())\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zero(Vec{3})), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    lh = LoadHandler(dh)\n    quad_order = 3\n    add!(lh, Neumann(:u, quad_order, getfaceset(grid, \"right\"), traction_function))\n\n    domainspec = DomainSpec(dh, material, cv)\n    return FEDefinition(domainspec; ch, lh)\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(zero(Vec{3}), FP.get_time(p), zero(Vec{3}))[3])\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.get_state(p), \"state\")\nend;\n\nfunction plot_results(post::PlasticityPostProcess;\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    plot!(plt, post.umag, post.tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem.post, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main types below are exported.  Remaining functions are not exported to avoid polluting the  name space. Tip: To simplify calling the following functions it is possible to write import FerriteProblems as FP as is done in the examples. ","category":"page"},{"location":"api/#Main-types","page":"API","title":"Main types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblem\nFEDefinition\nFerriteIO","category":"page"},{"location":"api/#FerriteProblems.FerriteProblem","page":"API","title":"FerriteProblems.FerriteProblem","text":"FerriteProblem(def::FEDefinition, post=nothing, io=nothing; kwargs...)\nFerriteProblem(def::FEDefinition, post, savefolder::String; kwargs...)\n\nCreate a FerriteProblem from def. Postprocessing can be added as post, see FESolvers.postprocess!. File input/output using FerriteIO can be added with io.  It is also possible to just give the savefolder, i.e. where  to save the output when the default FerriteIO can be used.\n\nSupported keyword arguments are\n\nautodiffbuffer::Bool: Should FerriteAssembly.jl's AutoDiffCellBuffer be used?  This will make the assembly faster if automatic differentiation is used, and can also be used  without automatic differentiation (but with a slight extra computational overhead)\nthreading::Bool: Should threading be used? \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FEDefinition","page":"API","title":"FerriteProblems.FEDefinition","text":"FEDefinition(\n    domainspec::Union{DomainSpec,Dict{String,DomainSpec}};\n    ch, lh=LoadHandler(dh),\n    convergence_criterion=AbsoluteResidual(), \n    initial_conditions=NamedTuple(),\n    )\n\nCreate the FEDefinition which can later be used to  create a complete FerriteProblem. domainspec is the FerriteAssembly domain specification.\n\nIn addition, the following keyword arguments can be given\n\nch: The constraint handler, ConstraintHandler (Ferrite.jl)\nlh: The external load handler, LoadHandler (FerriteAssembly.jl)\ninitial_conditions: NamedTuple with a function f(x) for each field that has a nonzero  initial condition. Used by the Ferrite.jl's apply_analytical! function. Example: initial_conditions = (u = x -> Vec((x[1]/10, 0.0)), p = x -> -100*x[2]).  For fields not given here, the initial condition is zeros everywhere.  \nconvergence_criterion: Determines how to calculate the convergence measure including scaling. See ConvergenceCriterion\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FerriteIO","page":"API","title":"FerriteProblems.FerriteIO","text":"FerriteIO(\n    folder::String, def::FEDefinition, post=nothing; \n    def_file=\"FEDefinition.jld2\", \n    postfile=\"FEPost.jld2\",\n    T=Float64, \n    nsteps_per_file=typemax(Int), \n    switchsize=Inf\n    )\n\nConstructor for creating a FerriteIO when simulating. \n\n\n\n\n\nFerriteIO(filepath::String)\n\nConstructor for reading a FerriteIO that was saved during a simulation. The default filename is FerriteIO.jld2, located in the savefolder given  to the FerriteProblem constructor when setting up the simulation. \n\nCan be called either with the do-block (recommended),\n\nFerriteIO(filepath) do io\n    # Do whatever with io \nend\n\nor by manually closing,\n\nio = FerriteIO(filepath)\n# Do whatever with io\nclose(io)\n\n\n\n\n\n","category":"type"},{"location":"api/#Convergence-criteria","page":"API","title":"Convergence criteria","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In normal usage, the following convergence criteria can be used","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.ConvergenceCriterion\nFerriteProblems.AbsoluteResidual\nFerriteProblems.RelativeResidualElementScaling","category":"page"},{"location":"api/#FerriteProblems.ConvergenceCriterion","page":"API","title":"FerriteProblems.ConvergenceCriterion","text":"ConvergenceCriterion\n\nThe abstract type ConvergenceCriterion is the supertype for all  convergence criteria. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.AbsoluteResidual","page":"API","title":"FerriteProblems.AbsoluteResidual","text":"AbsoluteResidual()\n\nThe default convergence criterion that calculates the convergence measure as  √(sum([r[i]^2 for i ∈ free dofs]) without any scaling. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.RelativeResidualElementScaling","page":"API","title":"FerriteProblems.RelativeResidualElementScaling","text":"RelativeResidualElementScaling(p, minfactors::Union{AbstractFloat,NamedTuple}=eps())\n\nUse Ferriteassembly.ElementResidualScaling with the exponent p to calculate the  scaling for each field individually, based on the L2-norm of each cell's residual.  To avoid issues when all cells have zero residual (e.g. in the first time step), supply minfactors as the minimum scaling factor.  The convergence measure is calculated with the following pseudo-code\n\nval = 0.0\nfor field in Ferrite.getfieldnames(dh)\n    factor = max(element_residual_scaling[field], minfactors[field])\n    dofs = free_field_dofs[field]   # Get the non-constrained dofs for `field`\n    val += sum(i->(r[i]/factor)^2, dofs)\nend\nreturn √val\n\nwhere the same minfactor is used for all fields if only a scalar value is given. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"To create custom convergence criteria, the following functions  may require overloading. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.TolScaling\nFESolvers.calculate_convergence_measure\nFerriteProblems.make_assemscaling","category":"page"},{"location":"api/#FerriteProblems.TolScaling","page":"API","title":"FerriteProblems.TolScaling","text":"TolScaling(criterion::ConvergenceCriterion, def::FEDefinition)\n\nThe TolScaling type contains the criterion that determines how to scale the residuals to determine  convergence. The constructor is specialized on typeof(criterion), creating the following fields:\n\nassemscaling: scaling to be used by FerriteAssembly to give potential scaling contribution based on each element's residual\nbuffer: Used to pre-calculate values, such as dof-ranges for each field that is used when calculating the convergence measure. \n\n\n\n\n\n","category":"type"},{"location":"api/#FESolvers.calculate_convergence_measure","page":"API","title":"FESolvers.calculate_convergence_measure","text":"calculate_convergence_measure(problem, Δa, iter) -> AbstractFloat\n\nCalculate a value to be compared with the tolerance of the nonlinear solver.  A standard case when using Ferrite.jl is norm(getresidual(problem)[Ferrite.free_dofs(ch)])  where ch::Ferrite.ConstraintHandler. Δa is the update of the unknowns from  the previous iteration. Note that iter=1 implies Δa=0\n\nThe advanced API alternative is check_convergence_criteria\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.make_assemscaling","page":"API","title":"FerriteProblems.make_assemscaling","text":"make_assemscaling(criterion, def)\n\nCreate the scaling for use in FerriteAssembly if required by the given criterion. The default, if not overloaded, returns nothing. \n\n\n\n\n\n","category":"function"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.get_dofhandler\nFerriteProblems.get_constrainthandler\nFerriteProblems.get_loadhandler\nFerriteProblems.get_material\nFerriteProblems.getjacobian\nFerriteProblems.getunknowns\nFerriteProblems.getresidual\nFerriteProblems.get_external_force\nFerriteProblems.get_old_unknowns\nFerriteProblems.get_state\nFerriteProblems.get_old_state\nFerriteProblems.get_time\nFerriteProblems.get_old_time","category":"page"},{"location":"api/#FerriteAssembly.get_dofhandler","page":"API","title":"FerriteAssembly.get_dofhandler","text":"get_dofhandler(dbs::Dict{String,AbstractDomainBuffer})\nget_dofhandler(db::AbstractDomainBuffer)\n\nGet the dofhandler stored in db. Note that this is the global dofhandler, and not the SubDofHandler that is local to a specific domain.\n\n\n\n\n\nFerriteProblems.get_dofhandler(p::FerriteProblem)\n\nGet dh::Ferrite.AbstractDofHandler from the FerriteProblem (Technically overloaded from FerriteAssembly, but accessible via FerriteProblems)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_constrainthandler","page":"API","title":"FerriteProblems.get_constrainthandler","text":"FerriteProblems.get_constrainthandler(p::FerriteProblem)\n\nGet the ConstraintHandler from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_loadhandler","page":"API","title":"FerriteProblems.get_loadhandler","text":"FerriteProblems.get_loadhandler(p::FerriteProblem)\n\nGet the LoadHandler from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_material","page":"API","title":"FerriteAssembly.get_material","text":"get_material(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_material(db::AbstractDomainBuffer)\n\nGet the material for the domain represented by db or dbs[domain].\n\n\n\n\n\nFerriteProblems.get_material(p::FerriteProblem)\nFerriteProblems.get_material(p::FerriteProblem, domain_name::String)\n\nGet the material in p. For multiple domains, it is necessary to give the domain_name for where to get the material. Note that this is type-unstable and should be avoided in  performance-critical code sections. This function belongs to FerriteAssembly.jl,  but can be accessed via FerriteProblems.get_material.\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getjacobian","page":"API","title":"FESolvers.getjacobian","text":"getjacobian(problem)\n\nReturn the jacobian drdx, or approximations thereof.\n\nMust be defined for NewtonSolver, but can also be  defined by the advanced API alternative getsystemmatrix:  getsystemmatrix(problem, ::NewtonSolver)\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getunknowns","page":"API","title":"FESolvers.getunknowns","text":"getunknowns(problem)\n\nReturn the current vector of unknown values\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getresidual","page":"API","title":"FESolvers.getresidual","text":"getresidual(problem)\n\nReturn the current residual vector of the problem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_external_force","page":"API","title":"FerriteProblems.get_external_force","text":"FerriteProblems.getneumannforce(p::FerriteProblem)\n\nGet the current external force vector caused by  Neumann boundary conditions. Note that this vector  does not include external forces added during the  cell assembly; only forces added with the NeumannHandler\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_old_unknowns","page":"API","title":"FerriteProblems.get_old_unknowns","text":"FerriteProblems.get_old_unknowns(p::FerriteProblem)\n\nGet the vector of unknowns from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_state","page":"API","title":"FerriteAssembly.get_state","text":"get_state(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_state(db::Union{AbstractDomainBuffer,Dict{String,AbstractDomainBuffer}})\n\nGet the states::Dict{Int,S}, where S type of the state for each entity in the domain, stored in the db or dbs[domain]. If no domain is given for multiple domains, a  Dict{String} is returned with state variables for each domain\n\n\n\n\n\nFerriteProblems.get_state(p::FerriteProblem)\n\nGet the current state variables\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_old_state","page":"API","title":"FerriteAssembly.get_old_state","text":"get_old_state(itembuffer::AbstractCellBuffer)\n\nGet the old state variables for the cell. Currently only available for cells and not for faces. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_time","page":"API","title":"FerriteProblems.get_time","text":"FerriteProblems.get_time(p::FerriteProblem)\n\nGet the current time\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.get_old_time","page":"API","title":"FerriteProblems.get_old_time","text":"FerriteProblems.getoldtime(p::FerriteProblem)\n\nGet time of the previous converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#Saving-and-loading-data","page":"API","title":"Saving and loading data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FESolvers.postprocess!\nFerriteProblems.close_postprocessing\nFerriteProblems.addstep!\nFerriteProblems.gettimedata\nFerriteProblems.savedofdata!\nFerriteProblems.getdofdata\nFerriteProblems.savenodedata!\nFerriteProblems.getnodedata\nFerriteProblems.savecelldata!\nFerriteProblems.getcelldata\nFerriteProblems.saveipdata!\nFerriteProblems.getipdata\nFerriteProblems.saveglobaldata!\nFerriteProblems.getglobaldata\nFerriteProblems.getdef\nFerriteProblems.getpost","category":"page"},{"location":"api/#FESolvers.postprocess!","page":"API","title":"FESolvers.postprocess!","text":"postprocess!(problem, step, solver)\n\nPerform any postprocessing at the current time and step nr step Called at the beginning of the simulation,  and after time step converged right before handle_converged!.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.close_postprocessing","page":"API","title":"FerriteProblems.close_postprocessing","text":"close_postprocessing(post::MyPostType, p::FerriteProblem)\n\nThis function is called to close any open files manually created during  the postprocessing with the custom postprocessing type MyPostType.  Note that the file streams in p.io::FerriteIO are  automatically closed and don't require any special handling.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.addstep!","page":"API","title":"FerriteProblems.addstep!","text":"FerriteProblems.addstep!(io::FerriteIO, p::FerriteProblem)\n\nAdd a new step to be saved by io at the time gettime(p) Must be called before adding any new data\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettimedata","page":"API","title":"FerriteProblems.gettimedata","text":"gettimedata(io::FerriteIO)\ngettimedata(io::FerriteIO, step)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savedofdata!","page":"API","title":"FerriteProblems.savedofdata!","text":"FerriteProblems.savedofdata!(io::FerriteIO, vals, dt_order=0, field=\"dof\")\n\nSave data pertaining to each degree of freedom. Use a different field than \"dof\"` to save data located at each dof,  but not the actual dof values (e.g. the residual vector)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdofdata","page":"API","title":"FerriteProblems.getdofdata","text":"FerriteProblems.getdofdata(io::FerriteIO, step, field=\"dof\"; dt_order=0)\n\nGet the data saved by FerriteProblems.savedofdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savenodedata!","page":"API","title":"FerriteProblems.savenodedata!","text":"FerriteProblems.savenodedata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data located at each node. By convention this should be indexed by the node numbers in the grid. (E.g. a Vector for all nodes or a Dict{Int} with keys the node numbers)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnodedata","page":"API","title":"FerriteProblems.getnodedata","text":"FerriteProblems.getnodedata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.savenodedata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savecelldata!","page":"API","title":"FerriteProblems.savecelldata!","text":"FerriteProblems.savecelldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each cell.  By convention this should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcelldata","page":"API","title":"FerriteProblems.getcelldata","text":"FerriteProblems.getcelldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.savecelldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveipdata!","page":"API","title":"FerriteProblems.saveipdata!","text":"FerriteProblems.saveipdata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each integration point in cells in the grid.  By convention the data for each cell should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices) Note that it is on the user to know how the integration points are numbered,  i.e. which QuadratureRule that was used. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getipdata","page":"API","title":"FerriteProblems.getipdata","text":"FerriteProblems.getipdata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.saveipdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveglobaldata!","page":"API","title":"FerriteProblems.saveglobaldata!","text":"FerriteProblems.saveglobaldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data that is global to the entire simulation, i.e. global quantites such as  reaction forces, total dissipation, etc. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getglobaldata","page":"API","title":"FerriteProblems.getglobaldata","text":"FerriteProblems.getglobaldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.saveglobaldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdef","page":"API","title":"FerriteProblems.getdef","text":"FerriteProblems.getdef(io::FerriteIO)\n\nLoad the FEDefinition from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getpost","page":"API","title":"FerriteProblems.getpost","text":"FerriteProblems.getpost(io::FerriteIO)\n\nLoad the user defined post from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"EditURL = \"../literate/transient_heat.jl\"","category":"page"},{"location":"examples/transient_heat/#Linear-Time-Dependent-Problem","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This example is the same example as FESolvers.jl's transient heat flow which was taken from Ferrite.jl's transient heat flow. Please see the theoretical derivations in those examples, with the specific formulation used here in the former.","category":"page"},{"location":"examples/transient_heat/#Commented-Program","page":"Linear Time Dependent Problem","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Now we solve the problem by using FerriteProblems. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First we load required packages","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA","category":"page"},{"location":"examples/transient_heat/#Physics","page":"Linear Time Dependent Problem","title":"Physics","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First, we need to define the material behavior.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"@kwdef struct FourierMaterial{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"where we could have defined the heat source using the bodyload type available via the cellbuffer, but it is not necessary for a constant heat source.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define element routine following FerriteAssembly","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FourierMaterial, cellvalues, buffer\n    )\n    Δt = FA.get_time_increment(buffer)\n    ue_old = FA.get_aeold(buffer)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#Problem-setup","page":"Linear Time Dependent Problem","title":"Problem setup","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We start by a function that will create the problem definition","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); add!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    domainspec = DomainSpec(dh, FourierMaterial(), cellvalues)\n    return FEDefinition(domainspec; ch)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#Postprocessing","page":"Linear Time Dependent Problem","title":"Postprocessing","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"After defining all the physics and problem setup, we must decide what data to save. In this example, we use the vtk-file exports as in the original example. To this end, we define the custom postprocessing struct","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct TH_PostProcessing{PVD}\n    pvd::PVD\nend\nTH_PostProcessing() = TH_PostProcessing(paraview_collection(\"transient-heat.pvd\"));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And the postprocessing function that is called after each time step","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FESolvers.postprocess!(post::TH_PostProcessing, p, step, solver)\n    if step < 5 || mod(step, 20) == 0\n        @info \"postprocessing step $step\"\n        dh = FP.get_dofhandler(p)\n        vtk_grid(\"transient-heat-$step\", dh) do vtk\n            vtk_point_data(vtk, dh, FP.getunknowns(p))\n            vtk_save(vtk)\n            post.pvd[step] = vtk\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"At the end of the simulation, we want to finish all IO operations. We can then define the function close_postprocessing which will be called even in the case that an error is thrown during the simulation","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FP.close_postprocessing(post::TH_PostProcessing, p)\n    vtk_save(post.pvd)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And now we create the problem type, and define the QuasiStaticSolver with the LinearProblemSolver as well as fixed time steps","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"def = create_definition()\npost = TH_PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Finally, we can solve the problem","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"solve_problem!(problem, solver);\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#transient_heat_equation-plain-program","page":"Linear Time Dependent Problem","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat.jl.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA\n\n@kwdef struct FourierMaterial{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FourierMaterial, cellvalues, buffer\n    )\n    Δt = FA.get_time_increment(buffer)\n    ue_old = FA.get_aeold(buffer)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\n\nfunction create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); add!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    domainspec = DomainSpec(dh, FourierMaterial(), cellvalues)\n    return FEDefinition(domainspec; ch)\nend;\n\nstruct TH_PostProcessing{PVD}\n    pvd::PVD\nend\nTH_PostProcessing() = TH_PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(post::TH_PostProcessing, p, step, solver)\n    if step < 5 || mod(step, 20) == 0\n        @info \"postprocessing step $step\"\n        dh = FP.get_dofhandler(p)\n        vtk_grid(\"transient-heat-$step\", dh) do vtk\n            vtk_point_data(vtk, dh, FP.getunknowns(p))\n            vtk_save(vtk)\n            post.pvd[step] = vtk\n        end\n    end\nend;\n\nfunction FP.close_postprocessing(post::TH_PostProcessing, p)\n    vtk_save(post.pvd)\nend;\n\ndef = create_definition()\npost = TH_PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\n\nsolve_problem!(problem, solver);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"EditURL = \"../literate/io.jl\"","category":"page"},{"location":"examples/io/#IO:-Saving-and-loading-simulations","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"","category":"section"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"The FerriteProblems.jl package includes support for saving simulation data using JLD2.jl. This examples shows some examples of how this can be done. Specifically, we use the data saved during the plasticity example:","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"using Ferrite, FerriteProblems\nimport FerriteProblems as FP\ninclude(\"plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"In that example, the displacements and state variables were saved in each time step. In this example, we use the data saved in the folder B (using the AdaptiveTimeStepper) and plot a few interesting cases:","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Maximum von Mises stress as function of time\nExport the final displacements and stress to vtk","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"While it is possible to have a code that is structured like","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"io = FerriteIO(\"B/FerriteIO.jld2\")\n# do whatever\nclose(io)","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"We do everything inside a do-block to ensure everything is closed at the end (even if an error is thrown)","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"plts = FerriteIO(\"B/FerriteIO.jld2\") do io\n    def = FP.getdef(io)\n    post = FP.getpost(io);\n\n    # Then, we get the time history and the displacement data saved to the `post` struct\n    t_history = FP.gettimedata(io)\n    u_mag = post.umag\n\n    plt1 = plot()\n    plot!(plt1, t_history, u_mag*1e3)\n    title!(plt1, \"maximum displacement\")\n    xlabel!(plt1, \"time [s]\")\n    ylabel!(plt1, \"umax [mm]\")\n\n    # The maximum von Mises stress for each step is calculated next. Note that `step` refers\n    # to the count of saved steps, and not the actual simulation steps.\n    function get_max_vm_stress(io, step)\n        states = FP.getipdata(io, step, \"state\") # ::Dict{Int,Vector{J2PlasticityMaterialState}}\n        σ_vm = maximum(cellstates -> maximum(state -> vonMises(state.σ), cellstates), values(states))\n        return σ_vm\n    end\n\n    σ_vm = get_max_vm_stress.((io,), 1:length(t_history));\n\n    # Plot the analyzed results\n    plt2=plot()\n    plot!(plt2, t_history, σ_vm*1e-6)\n    title!(plt2, \"Maximum von Mises stress\")\n    xlabel!(plt2, \"time [s]\")\n    ylabel!(plt2, \"stress [MPa]\")\n\n    # Finally, we extract the degrees of freedom and the stresses in each element\n    # at the last step to save to vtk.\n    step = length(t_history)\n    u = FP.getdofdata(io, step)\n    states = FP.getipdata(io, step, \"state\")\n    dh = FP.get_dofhandler(def)\n    mises_values = zeros(getncells(dh.grid))\n    for (el, cell_states) in pairs(states) # states::Dict{Int}\n        for state in cell_states\n            mises_values[el] += vonMises(state.σ)\n        end\n        mises_values[el] /= length(cell_states) # average von Mises stress\n    end\n    vtk_grid(\"plasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u) # displacement field\n        vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\n    end;\n    # Return the plots\n    (plt1, plt2)\nend","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Display the plots by running display(plts[1]) or display(plts[2])","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the  FESolvers.jl package with  Ferrite.jl, using the  FerriteAssembly.jl for assembly and element interfaces.  There is also preliminary support for organizing your simulations  by saving both setup and results as .jld2 using JLD2.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"All unregistered dependencies, including FerriteProblems.jl itself,  is available in the knutamregistry","category":"page"},{"location":"#Simple-workflow","page":"Home","title":"Simple workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The easiest way to get started is to just follow the examples, but in brief the workflow for a simple setup is","category":"page"},{"location":"","page":"Home","title":"Home","text":"def = FEDefinition(;dh=dh, ch=ch, material=material, cellvalues=cellvalues)\nproblem = FerriteProblem(def)\nsolver = QuasiStaticSolver(NewtonSolver(), FixedTimeStepper(;num_steps=10,Δt=0.1))\nsolve_problem!(problem, solver)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the documentation of Ferrite.jl, FESolvers.jl, and FerriteAssembly.jl should be considered as well. ","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note: These functions are not considered \"documented\" and changes here are therefore not considered breaking.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteProblems.FEBuffer\nFerriteProblems.get_tolerance_scaling\nFerriteProblems.update_unknowns!\nFerriteProblems.set_time!\nFerriteProblems.update_time!\nFerriteProblems.filepath\nFerriteProblems.datafilepath\nFerriteProblems.new_file!\nFerriteProblems.new_file_if_needed!\nFerriteProblems.update_currentsize!\nFerriteProblems.getfilenumber\nFerriteProblems.open_if_needed!\nFerriteProblems.close_io\nFerriteProblems.checkkey\nFerriteProblems.savedata!\nFerriteProblems.getdata","category":"page"},{"location":"internals/#FerriteProblems.FEBuffer","page":"Internals","title":"FerriteProblems.FEBuffer","text":"FEBuffer(K,x,r,f,xold,cellbuffer,state,old_state,time,old_time)\n\nA buffer to hold all values that are required to simulate,  but that are uniqely defined from the simulation definition\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteProblems.get_tolerance_scaling","page":"Internals","title":"FerriteProblems.get_tolerance_scaling","text":"FerriteProblems.get_tolerance_scaling(p::FerriteProblem)\n\nGet the TolScaling type that controls the convergence  measure to be compared with the solver's tolerance\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_unknowns!","page":"Internals","title":"FerriteProblems.update_unknowns!","text":"FerriteProblems.update_unknowns!(p::FerriteProblem)\n\nUpdate the vector of \"old\" unknowns to the values of the current vector of unknowns\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.set_time!","page":"Internals","title":"FerriteProblems.set_time!","text":"FerriteProblems.settime!(p::FerriteProblem, new_time)\n\nSet the current time to new_time Called when starting a new step (or when attempting the same  step number with a new time increment)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_time!","page":"Internals","title":"FerriteProblems.update_time!","text":"FerriteProblems.update_time!(p::FerriteProblem)\n\nUpdate the old time to the current time.  Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.filepath","page":"Internals","title":"FerriteProblems.filepath","text":"filepath(io::FerriteIO, args...) = joinpath(io.folder, args...)\n\nGet the path of a file relative io's folder\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.datafilepath","page":"Internals","title":"FerriteProblems.datafilepath","text":"datafilepath(io::FerriteIO, num=length(io.datafiles))\n\nGet the path of the data file number num in io.datafiles\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file!","page":"Internals","title":"FerriteProblems.new_file!","text":"new_file!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file_if_needed!","page":"Internals","title":"FerriteProblems.new_file_if_needed!","text":"new_file_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_currentsize!","page":"Internals","title":"FerriteProblems.update_currentsize!","text":"update_currentsize!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getfilenumber","page":"Internals","title":"FerriteProblems.getfilenumber","text":"getfilenumber\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.open_if_needed!","page":"Internals","title":"FerriteProblems.open_if_needed!","text":"open_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.close_io","page":"Internals","title":"FerriteProblems.close_io","text":"close_io(io::FerriteIO, post)\n\nClose the currently open file in io, then the postprocessing  struct to a jld2 file (if not post != nothing), before finally saving the current io object to a .jld2 file\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.checkkey","page":"Internals","title":"FerriteProblems.checkkey","text":"checkkey\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.savedata!","page":"Internals","title":"FerriteProblems.savedata!","text":"savedata!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getdata","page":"Internals","title":"FerriteProblems.getdata","text":"getdata\n\n\n\n\n\n","category":"function"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"EditURL = \"../literate/porous_media.jl\"","category":"page"},{"location":"examples/porous_media/#Porous-media","page":"Porous media","title":"Porous media","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Porous media is a two-phase material, consisting of solid parts and a liquid occupying the pores inbetween. Using the porous media theory, we can model such a material without explicitly resolving the microstructure, but by considering the interactions between the solid and liquid. In this example, we will additionally consider larger linear elastic solid aggregates that are impermeable. Hence, there is no liquids in these particles and the only unknown variable is the displacement field :u. In the porous media, denoted the matrix, we have both the displacement field, :u, as well as the liquid pressure, :p, as unknown. The computational domain is shown below (the outdated figure doesn't show correct boundary conditions)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"<table><tbody><tr height=\"300px\"><td style=\"text-align: left;\">","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Computational domain)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Pressure evolution)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Pressure legend)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: u2 evolution)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: u2 legend)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</tr><tr><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Computational domain","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Pressure evolution","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td></td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Vertical displacements¨","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td></tr></tbody></table>","category":"page"},{"location":"examples/porous_media/#Theory-of-porous-media","page":"Porous media","title":"Theory of porous media","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"The strong forms are given as","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nboldsymbolsigma(boldsymbolepsilon p) cdot boldsymbolnabla = boldsymbol0 \ndotPhi(boldsymbolepsilon p) + boldsymbolw(p) cdot boldsymbolnabla = 0\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"where boldsymbolepsilon = leftboldsymboluotimesboldsymbolnablaright^mathrmsym The constitutive relationships are","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nboldsymbolsigma = boldsymbolmathsfEboldsymbolepsilon - alpha p boldsymbolI \nboldsymbolw = - k boldsymbolnabla p \nPhi = phi + alpha mathrmtr(boldsymbolepsilon) + beta p\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"with boldsymbolmathsfE=2G boldsymbolmathsfI^mathrmdev + 3K boldsymbolIotimesboldsymbolI. The material parameters are then the shear modulus, G, bulk modulus, K, permeability, k, Biot's coefficient, alpha, and liquid compressibility, beta. The porosity, phi, doesn't enter into the equations (A different porosity leads to different skeleton stiffness and permeability).","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"The variational (weak) form can then be derived for the variations boldsymboldelta u and delta p as","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nint_Omega leftleftboldsymboldelta uotimesboldsymbolnablaright^mathrmsym\nboldsymbolmathsfEboldsymbolepsilon - boldsymboldelta u cdot boldsymbolnabla alpha pright mathrmdOmega\n= int_Gamma boldsymboldelta u cdot boldsymbolt mathrmd Gamma \nint_Omega leftdelta p leftalpha dotboldsymbolu cdot boldsymbolnabla + beta dotpright +\nboldsymbolnabla(delta p) cdot k boldsymbolnablaright mathrmdOmega\n= int_Gamma delta p w_mathrmn mathrmd Gamma\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"where boldsymbolt=boldsymbolncdotboldsymbolsigma is the traction and w_mathrmn = boldsymbolncdotboldsymbolw is the normal flux.","category":"page"},{"location":"examples/porous_media/#Finite-element-form","page":"Porous media","title":"Finite element form","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Discretizing in space using finite elements, we obtain the vector equation r_i = f_i^mathrmint - f_i^mathrmext where f^mathrmext are the external \"forces\", and f_i^mathrmint are the internal \"forces\". We split this into the displacement part r_i^mathrmu = f_i^mathrmintu - f_i^mathrmextu and pressure part r_i^mathrmp = f_i^mathrmintp - f_i^mathrmextp to obtain the discretized equation system","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nf_i^mathrmintu = int_Omega boldsymboldelta N^mathrmu_iotimesboldsymbolnabla^mathrmsym  boldsymbolmathsfE  boldsymboluotimesboldsymbolnabla^mathrmsym \n- boldsymboldelta N^mathrmu_i cdot boldsymbolnabla alpha p mathrmdOmega\n= int_Gamma boldsymboldelta N^mathrmu_i cdot boldsymbolt mathrmd Gamma \nf_i^mathrmintp = int_Omega delta N_i^mathrmp alpha dotboldsymbolucdotboldsymbolnabla  + betadotp + boldsymbolnabla(delta N_i^mathrmp) cdot k boldsymbolnabla(p) mathrmdOmega\n= int_Gamma delta N_i^mathrmp w_mathrmn mathrmd Gamma\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Approximating the time-derivatives, dotboldsymboluapprox leftboldsymbolu-^nboldsymbolurightDelta t and dotpapprox leftp-^nprightDelta t, we can implement the finite element equations in the residual form r_i(boldsymbola(t) t) = 0 where the vector boldsymbola contains all unknown displacements u_i and pressures p_i. We use automatic differentiation to get the jacobian.","category":"page"},{"location":"examples/porous_media/#Implementation","page":"Porous media","title":"Implementation","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"We now solve the problem step by step. The full program with fewer comments is found in the final section","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Required packages","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"using Ferrite, FerriteMeshParser, Tensors\nusing FerriteAssembly, FerriteProblems, FESolvers\nusing MaterialModelsBase\nimport FerriteProblems as FP\nimport MaterialModelsBase as MMB","category":"page"},{"location":"examples/porous_media/#Physics","page":"Porous media","title":"Physics","text":"","category":"section"},{"location":"examples/porous_media/#Elastic-material","page":"Porous media","title":"Elastic material","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"For the elastic material, we just define the material following the MaterialModelsBase.jl interface:","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct Elastic{T} <: AbstractMaterial\n    G::T\n    K::T\n    E4::SymmetricTensor{4,2,T,9}\nend\nfunction Elastic(;E=2.e3, ν=0.3)\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n    I2 = one(SymmetricTensor{2,2})\n    I4vol = I2⊗I2\n    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3\n    E4 = 2G*I4dev + K*I4vol\n    return Elastic(G, K, E4)\nend;\n\nfunction MMB.material_response(m::Elastic, ϵ, args...; kwargs...)\n    σ = m.E4 ⊡ ϵ\n    return σ, m.E4, NoMaterialState()\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Poroelastic-material","page":"Porous media","title":"Poroelastic material","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"For the poroelastic material, we reuse the elastic part from above, but add additionally required properties","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct PoroElastic{E<:Elastic,T}\n    elastic::E\n    k::T    # [mm^4/Ns] Permeability\n    α::T    # [-] Biot's coefficient\n    β::T    # [1/MPa] Liquid bulk modulus\nend\nfunction PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)\n    return PoroElastic(elastic, k, α, β)\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"And then we also have to define the specific element routine which we do by defining the residual and using autodiff to calculate the tangent","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, buffer)\n    cv_u = cv[:u] # Cellvalues for displacements\n    cv_p = cv[:p] # Cellvalues for the pressure\n    Δt = FerriteAssembly.get_time_increment(buffer)\n\n    ae_old = FerriteAssembly.get_aeold(buffer)  # Old element degrees of freedom\n    udofs = dof_range(buffer, :u)               # Element dof indices for displacements\n    pdofs = dof_range(buffer, :p)               # ELement dof indices for the pressure\n\n    # Assemble stiffness and force vectors\n    for q_point in 1:getnquadpoints(cv_u)\n        # Calculate variables in the current quadrature point\n        dΩ = getdetJdV(cv_u, q_point)\n        ϵ = function_symmetric_gradient(cv_u, q_point, ae, udofs)\n        ϵ_old = function_symmetric_gradient(cv_u, q_point, ae_old, udofs)\n        p = function_value(cv_p, q_point, ae, pdofs)\n        p_old = function_value(cv_p, q_point, ae_old, pdofs)\n        ∇p = function_gradient(cv_p, q_point, ae, pdofs)\n        pdot = (p-p_old)/Δt\n        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt\n        σeff = material.elastic.E4 ⊡ ϵ\n\n        # Assemble residual contributions\n        for (iᵤ, Iᵤ) in pairs(udofs)\n            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)\n            div_δNu = shape_divergence(cv_u, q_point, iᵤ)\n            re[Iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ\n        end\n        for (iₚ, Iₚ) in pairs(pdofs)\n            δNp = shape_value(cv_p, q_point, iₚ)\n            ∇δNp = shape_gradient(cv_p, q_point, iₚ)\n            re[Iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Problem-definition","page":"Porous media","title":"Problem definition","text":"","category":"section"},{"location":"examples/porous_media/#Mesh-import","page":"Porous media","title":"Mesh import","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"In this example, we import the mesh from the Abaqus input file, porous_media_0p75.inp using FerriteMeshParser's get_ferrite_grid function. (A finer mesh, porous_media_0p25.inp, is also available) We then create one cellset for each phase (solid and porous) for each element type. These 4 sets will later be used in their own FieldHandler","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function get_grid()\n    # Import grid from abaqus mesh\n    grid = get_ferrite_grid(joinpath(@__DIR__, \"porous_media\", \"porous_media_0p75.inp\"))\n\n    # Create cellsets for each fieldhandler\n    addcellset!(grid, \"solid3\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"solid4\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS4R\")))\n    addcellset!(grid, \"porous3\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"porous4\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS4R\")))\n\n    # Create faceset for the sides and top\n    addfaceset!(grid, \"sides\", x->(first(x) < eps() || first(x) ≈ 5.0))\n    addfaceset!(grid, \"top\", x->(last(x) ≈ 10.0))\n    return grid\nend","category":"page"},{"location":"examples/porous_media/#Problem-setup","page":"Porous media","title":"Problem setup","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Define the finite element interpolation, integration, and boundary conditions.","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function create_definition(;t_rise=0.1, p_max=100.0)\n\n    grid = get_grid()\n\n    # Setup the interpolation and integration rules\n    dim=Ferrite.getdim(grid)\n    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()\n    ip4_lin = Lagrange{dim, RefCube, 1}()\n    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()\n    ip4_quad = Lagrange{dim, RefCube, 2}()\n    qr3 = QuadratureRule{dim, RefTetrahedron}(1)\n    qr4 = QuadratureRule{dim, RefCube}(2)\n\n    # Setup the MixedDofHandler\n    dh = MixedDofHandler(grid)\n    fh1 = FieldHandler([Field(:u, ip3_quad, dim)], getcellset(grid,\"solid3\"))\n    add!(dh, fh1)\n    fh2 = FieldHandler([Field(:u, ip4_quad, dim)], getcellset(grid,\"solid4\"))\n    add!(dh, fh2)\n    fh3 = FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,\"porous3\"))\n    add!(dh, fh3)\n    fh4 = FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,\"porous4\"))\n    add!(dh, fh4)\n    close!(dh)\n\n    # Setup each domain\n    domains = Dict{String,DomainSpec}()\n    # Solid domain with Triangle elements, quadratic displacement interpolation\n    sdh1 = FerriteAssembly.SubDofHandler(dh, fh1)\n    cv1 = CellVectorValues(qr3, ip3_quad, ip3_lin)\n    domains[\"solid3\"] = DomainSpec(sdh1, Elastic(), cv1)\n\n    # Solid domain with Quadrilateral elements, quadratic displacement interpolation\n    sdh2 = FerriteAssembly.SubDofHandler(dh, fh2)\n    cv2 = CellVectorValues(qr4, ip4_quad, ip4_lin)\n    domains[\"solid4\"] = DomainSpec(sdh2, Elastic(), cv2)\n\n    # Porous domain with Triangle elements\n    # Taylor hood: (quadratic displacement and linear pressure interpolation)\n    sdh3 = FerriteAssembly.SubDofHandler(dh, fh3)\n    cv3 = (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin))\n    domains[\"porous3\"] = DomainSpec(sdh3, PoroElastic(), cv3)\n\n    # Porous domain with Quadrilateral elements\n    # Taylor hood: (quadratic displacement and linear pressure interpolation)\n    sdh4 = FerriteAssembly.SubDofHandler(dh, fh4)\n    cv4 = (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin))\n    domains[\"porous4\"] = DomainSpec(sdh4, PoroElastic(), cv4)\n\n    # Add boundary conditions\n    ch = ConstraintHandler(dh);\n    # Fix bottom in y and sides in x\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"bottom\"), Returns(0.0), [2]))\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"sides\"), Returns(0.0), [1]))\n    # Zero pressure on top surface\n    add!(ch, Dirichlet(:p, getfaceset(grid, \"top\"), Returns(0.0)))\n    close!(ch)\n\n    # Add Neumann boundary conditions - normal traction on top\n    lh = LoadHandler(dh);\n    add!(lh, Neumann(:u, 2, getfaceset(grid, \"top\"), (x,t,n) -> -n*clamp(t/t_rise,0,1)*p_max))\n\n    return FEDefinition(domains; ch, lh)\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Postprocessing","page":"Porous media","title":"Postprocessing","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct PM_PostProcess{PVD}\n    pvd::PVD\n    filestem::String\nend\nfunction PM_PostProcess(filestem=\"porous_media\")\n    pvd = paraview_collection(\"$filestem.pvd\")\n    return PM_PostProcess(pvd, filestem)\nend\n\nfunction FESolvers.postprocess!(post::PM_PostProcess, p, step, solver)\n    vtk_grid(\"$(post.filestem)-$step\", FP.get_dofhandler(p)) do vtk\n        vtk_point_data(vtk, FP.get_dofhandler(p), FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend\n\nFP.close_postprocessing(post::PM_PostProcess, args...) = vtk_save(post.pvd);\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Solving","page":"Porous media","title":"Solving","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"We solve the problem by using linearly increasing time steps","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"problem = FerriteProblem(create_definition(), PM_PostProcess())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x->x^2, range(0, 1, 41))))\nsolve_problem!(problem, solver)","category":"page"},{"location":"examples/porous_media/#porous-media-plain-program","page":"Porous media","title":"Plain program","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Here follows a version of the program without any comments. The file is also available here: porous_media.jl.","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"using Ferrite, FerriteMeshParser, Tensors\nusing FerriteAssembly, FerriteProblems, FESolvers\nusing MaterialModelsBase\nimport FerriteProblems as FP\nimport MaterialModelsBase as MMB\n\nstruct Elastic{T} <: AbstractMaterial\n    G::T\n    K::T\n    E4::SymmetricTensor{4,2,T,9}\nend\nfunction Elastic(;E=2.e3, ν=0.3)\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n    I2 = one(SymmetricTensor{2,2})\n    I4vol = I2⊗I2\n    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3\n    E4 = 2G*I4dev + K*I4vol\n    return Elastic(G, K, E4)\nend;\n\nfunction MMB.material_response(m::Elastic, ϵ, args...; kwargs...)\n    σ = m.E4 ⊡ ϵ\n    return σ, m.E4, NoMaterialState()\nend;\n\nstruct PoroElastic{E<:Elastic,T}\n    elastic::E\n    k::T    # [mm^4/Ns] Permeability\n    α::T    # [-] Biot's coefficient\n    β::T    # [1/MPa] Liquid bulk modulus\nend\nfunction PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)\n    return PoroElastic(elastic, k, α, β)\nend;\n\nfunction FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, buffer)\n    cv_u = cv[:u] # Cellvalues for displacements\n    cv_p = cv[:p] # Cellvalues for the pressure\n    Δt = FerriteAssembly.get_time_increment(buffer)\n\n    ae_old = FerriteAssembly.get_aeold(buffer)  # Old element degrees of freedom\n    udofs = dof_range(buffer, :u)               # Element dof indices for displacements\n    pdofs = dof_range(buffer, :p)               # ELement dof indices for the pressure\n\n    # Assemble stiffness and force vectors\n    for q_point in 1:getnquadpoints(cv_u)\n        # Calculate variables in the current quadrature point\n        dΩ = getdetJdV(cv_u, q_point)\n        ϵ = function_symmetric_gradient(cv_u, q_point, ae, udofs)\n        ϵ_old = function_symmetric_gradient(cv_u, q_point, ae_old, udofs)\n        p = function_value(cv_p, q_point, ae, pdofs)\n        p_old = function_value(cv_p, q_point, ae_old, pdofs)\n        ∇p = function_gradient(cv_p, q_point, ae, pdofs)\n        pdot = (p-p_old)/Δt\n        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt\n        σeff = material.elastic.E4 ⊡ ϵ\n\n        # Assemble residual contributions\n        for (iᵤ, Iᵤ) in pairs(udofs)\n            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)\n            div_δNu = shape_divergence(cv_u, q_point, iᵤ)\n            re[Iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ\n        end\n        for (iₚ, Iₚ) in pairs(pdofs)\n            δNp = shape_value(cv_p, q_point, iₚ)\n            ∇δNp = shape_gradient(cv_p, q_point, iₚ)\n            re[Iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ\n        end\n    end\nend;\n\nfunction get_grid()\n    # Import grid from abaqus mesh\n    grid = get_ferrite_grid(joinpath(@__DIR__, \"porous_media\", \"porous_media_0p75.inp\"))\n\n    # Create cellsets for each fieldhandler\n    addcellset!(grid, \"solid3\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"solid4\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS4R\")))\n    addcellset!(grid, \"porous3\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"porous4\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS4R\")))\n\n    # Create faceset for the sides and top\n    addfaceset!(grid, \"sides\", x->(first(x) < eps() || first(x) ≈ 5.0))\n    addfaceset!(grid, \"top\", x->(last(x) ≈ 10.0))\n    return grid\nend\n\nfunction create_definition(;t_rise=0.1, p_max=100.0)\n\n    grid = get_grid()\n\n    # Setup the interpolation and integration rules\n    dim=Ferrite.getdim(grid)\n    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()\n    ip4_lin = Lagrange{dim, RefCube, 1}()\n    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()\n    ip4_quad = Lagrange{dim, RefCube, 2}()\n    qr3 = QuadratureRule{dim, RefTetrahedron}(1)\n    qr4 = QuadratureRule{dim, RefCube}(2)\n\n    # Setup the MixedDofHandler\n    dh = MixedDofHandler(grid)\n    fh1 = FieldHandler([Field(:u, ip3_quad, dim)], getcellset(grid,\"solid3\"))\n    add!(dh, fh1)\n    fh2 = FieldHandler([Field(:u, ip4_quad, dim)], getcellset(grid,\"solid4\"))\n    add!(dh, fh2)\n    fh3 = FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,\"porous3\"))\n    add!(dh, fh3)\n    fh4 = FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,\"porous4\"))\n    add!(dh, fh4)\n    close!(dh)\n\n    # Setup each domain\n    domains = Dict{String,DomainSpec}()\n    # Solid domain with Triangle elements, quadratic displacement interpolation\n    sdh1 = FerriteAssembly.SubDofHandler(dh, fh1)\n    cv1 = CellVectorValues(qr3, ip3_quad, ip3_lin)\n    domains[\"solid3\"] = DomainSpec(sdh1, Elastic(), cv1)\n\n    # Solid domain with Quadrilateral elements, quadratic displacement interpolation\n    sdh2 = FerriteAssembly.SubDofHandler(dh, fh2)\n    cv2 = CellVectorValues(qr4, ip4_quad, ip4_lin)\n    domains[\"solid4\"] = DomainSpec(sdh2, Elastic(), cv2)\n\n    # Porous domain with Triangle elements\n    # Taylor hood: (quadratic displacement and linear pressure interpolation)\n    sdh3 = FerriteAssembly.SubDofHandler(dh, fh3)\n    cv3 = (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin))\n    domains[\"porous3\"] = DomainSpec(sdh3, PoroElastic(), cv3)\n\n    # Porous domain with Quadrilateral elements\n    # Taylor hood: (quadratic displacement and linear pressure interpolation)\n    sdh4 = FerriteAssembly.SubDofHandler(dh, fh4)\n    cv4 = (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin))\n    domains[\"porous4\"] = DomainSpec(sdh4, PoroElastic(), cv4)\n\n    # Add boundary conditions\n    ch = ConstraintHandler(dh);\n    # Fix bottom in y and sides in x\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"bottom\"), Returns(0.0), [2]))\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"sides\"), Returns(0.0), [1]))\n    # Zero pressure on top surface\n    add!(ch, Dirichlet(:p, getfaceset(grid, \"top\"), Returns(0.0)))\n    close!(ch)\n\n    # Add Neumann boundary conditions - normal traction on top\n    lh = LoadHandler(dh);\n    add!(lh, Neumann(:u, 2, getfaceset(grid, \"top\"), (x,t,n) -> -n*clamp(t/t_rise,0,1)*p_max))\n\n    return FEDefinition(domains; ch, lh)\nend;\n\nstruct PM_PostProcess{PVD}\n    pvd::PVD\n    filestem::String\nend\nfunction PM_PostProcess(filestem=\"porous_media\")\n    pvd = paraview_collection(\"$filestem.pvd\")\n    return PM_PostProcess(pvd, filestem)\nend\n\nfunction FESolvers.postprocess!(post::PM_PostProcess, p, step, solver)\n    vtk_grid(\"$(post.filestem)-$step\", FP.get_dofhandler(p)) do vtk\n        vtk_point_data(vtk, FP.get_dofhandler(p), FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend\n\nFP.close_postprocessing(post::PM_PostProcess, args...) = vtk_save(post.pvd);\n\nproblem = FerriteProblem(create_definition(), PM_PostProcess())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x->x^2, range(0, 1, 41))))\nsolve_problem!(problem, solver)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"This page was generated using Literate.jl.","category":"page"}]
}
