<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Porous media · FerriteProblems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteProblems.jl/examples/porous_media/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FerriteProblems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../plasticity/">Plasticity</a></li><li><a class="tocitem" href="../io/">IO: Saving and loading simulations</a></li><li><a class="tocitem" href="../transient_heat/">Linear Time Dependent Problem</a></li><li><a class="tocitem" href="../incompressible_elasticity/">Incompressible Elasticity</a></li><li class="is-active"><a class="tocitem" href>Porous media</a><ul class="internal"><li><a class="tocitem" href="#Theory-of-porous-media"><span>Theory of porous media</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Physics"><span>Physics</span></a></li><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Postprocessing"><span>Postprocessing</span></a></li><li><a class="tocitem" href="#Solving"><span>Solving</span></a></li><li><a class="tocitem" href="#porous-media-plain-program"><span>Plain program</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Porous media</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Porous media</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/porous_media.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Porous-media"><a class="docs-heading-anchor" href="#Porous-media">Porous media</a><a id="Porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Porous-media" title="Permalink"></a></h1><p>Porous media is a two-phase material, consisting of solid parts and a liquid occupying the pores inbetween. Using the porous media theory, we can model such a material without explicitly resolving the microstructure, but by considering the interactions between the solid and liquid. In this example, we will additionally consider larger linear elastic solid aggregates that are impermeable. Hence, there is no liquids in these particles and the only unknown variable is the displacement field <code>:u</code>. In the porous media, denoted the matrix, we have both the displacement field, <code>:u</code>, as well as the liquid pressure, <code>:p</code>, as unknown. The computational domain is shown below (<em>the outdated figure doesn&#39;t show correct boundary conditions</em>)</p><table><tbody><tr height="300px"><td style="text-align: left;"><p><img src="domain.svg" alt="Computational domain"/></p></td><td><p><img src="pressure.gif" alt="Pressure evolution"/></p></td><td><p><img src="pressure_legend.png" alt="Pressure legend"/></p></td><td><p><img src="u2.gif" alt="u2 evolution"/></p></td><td><p><img src="u2_legend.png" alt="u2 legend"/></p></tr><tr><td><p>Computational domain</p></td><td><p>Pressure evolution</p></td><td></td><td><p>Vertical displacements¨</p></td><td></td></tr></tbody></table><h2 id="Theory-of-porous-media"><a class="docs-heading-anchor" href="#Theory-of-porous-media">Theory of porous media</a><a id="Theory-of-porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-of-porous-media" title="Permalink"></a></h2><p>The strong forms are given as</p><p class="math-container">\[\begin{aligned}
\boldsymbol{\sigma}(\boldsymbol{\epsilon}, p) \cdot \boldsymbol{\nabla} &amp;= \boldsymbol{0} \\
\dot{\Phi}(\boldsymbol{\epsilon}, p) + \boldsymbol{w}(p) \cdot \boldsymbol{\nabla} &amp;= 0
\end{aligned}\]</p><p>where <span>$\boldsymbol{\epsilon} = \left[\boldsymbol{u}\otimes\boldsymbol{\nabla}\right]^\mathrm{sym}$</span> The constitutive relationships are</p><p class="math-container">\[\begin{aligned}
\boldsymbol{\sigma} &amp;= \boldsymbol{\mathsf{E}}:\boldsymbol{\epsilon} - \alpha p \boldsymbol{I} \\
\boldsymbol{w} &amp;= - k \boldsymbol{\nabla} p \\
\Phi &amp;= \phi + \alpha \mathrm{tr}(\boldsymbol{\epsilon}) + \beta p
\end{aligned}\]</p><p>with <span>$\boldsymbol{\mathsf{E}}=2G \boldsymbol{\mathsf{I}}^\mathrm{dev} + 3K \boldsymbol{I}\otimes\boldsymbol{I}$</span>. The material parameters are then the shear modulus, <span>$G$</span>, bulk modulus, <span>$K$</span>, permeability, <span>$k$</span>, Biot&#39;s coefficient, <span>$\alpha$</span>, and liquid compressibility, <span>$\beta$</span>. The porosity, <span>$\phi$</span>, doesn&#39;t enter into the equations (A different porosity leads to different skeleton stiffness and permeability).</p><p>The variational (weak) form can then be derived for the variations <span>$\boldsymbol{\delta u}$</span> and <span>$\delta p$</span> as</p><p class="math-container">\[\begin{aligned}
\int_\Omega \left[\left[\boldsymbol{\delta u}\otimes\boldsymbol{\nabla}\right]^\mathrm{sym}:
\boldsymbol{\mathsf{E}}:\boldsymbol{\epsilon} - \boldsymbol{\delta u} \cdot \boldsymbol{\nabla} \alpha p\right] \mathrm{d}\Omega
&amp;= \int_\Gamma \boldsymbol{\delta u} \cdot \boldsymbol{t} \mathrm{d} \Gamma \\
\int_\Omega \left[\delta p \left[\alpha \dot{\boldsymbol{u}} \cdot \boldsymbol{\nabla} + \beta \dot{p}\right] +
\boldsymbol{\nabla}(\delta p) \cdot [k \boldsymbol{\nabla}]\right] \mathrm{d}\Omega
&amp;= \int_\Gamma \delta p w_\mathrm{n} \mathrm{d} \Gamma
\end{aligned}\]</p><p>where <span>$\boldsymbol{t}=\boldsymbol{n}\cdot\boldsymbol{\sigma}$</span> is the traction and <span>$w_\mathrm{n} = \boldsymbol{n}\cdot\boldsymbol{w}$</span> is the normal flux.</p><h3 id="Finite-element-form"><a class="docs-heading-anchor" href="#Finite-element-form">Finite element form</a><a id="Finite-element-form-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-form" title="Permalink"></a></h3><p>Discretizing in space using finite elements, we obtain the vector equation <span>$r_i = f_i^\mathrm{int} - f_{i}^\mathrm{ext}$</span> where <span>$f^\mathrm{ext}$</span> are the external &quot;forces&quot;, and <span>$f_i^\mathrm{int}$</span> are the internal &quot;forces&quot;. We split this into the displacement part <span>$r_i^\mathrm{u} = f_i^\mathrm{int,u} - f_{i}^\mathrm{ext,u}$</span> and pressure part <span>$r_i^\mathrm{p} = f_i^\mathrm{int,p} - f_{i}^\mathrm{ext,p}$</span> to obtain the discretized equation system</p><p class="math-container">\[\begin{aligned}
f_i^\mathrm{int,u} &amp;= \int_\Omega [\boldsymbol{\delta N}^\mathrm{u}_i\otimes\boldsymbol{\nabla}]^\mathrm{sym} : \boldsymbol{\mathsf{E}} : [\boldsymbol{u}\otimes\boldsymbol{\nabla}]^\mathrm{sym} \
- [\boldsymbol{\delta N}^\mathrm{u}_i \cdot \boldsymbol{\nabla}] \alpha p \mathrm{d}\Omega
&amp;= \int_\Gamma \boldsymbol{\delta N}^\mathrm{u}_i \cdot \boldsymbol{t} \mathrm{d} \Gamma \\
f_i^\mathrm{int,p} &amp;= \int_\Omega \delta N_i^\mathrm{p} [\alpha [\dot{\boldsymbol{u}}\cdot\boldsymbol{\nabla}]  + \beta\dot{p}] + \boldsymbol{\nabla}(\delta N_i^\mathrm{p}) \cdot [k \boldsymbol{\nabla}(p)] \mathrm{d}\Omega
&amp;= \int_\Gamma \delta N_i^\mathrm{p} w_\mathrm{n} \mathrm{d} \Gamma
\end{aligned}\]</p><p>Approximating the time-derivatives, <span>$\dot{\boldsymbol{u}}\approx \left[\boldsymbol{u}-{}^n\boldsymbol{u}\right]/\Delta t$</span> and <span>$\dot{p}\approx \left[p-{}^np\right]/\Delta t$</span>, we can implement the finite element equations in the residual form <span>$r_i(\boldsymbol{a}(t), t) = 0$</span> where the vector <span>$\boldsymbol{a}$</span> contains all unknown displacements <span>$u_i$</span> and pressures <span>$p_i$</span>. We use automatic differentiation to get the jacobian.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>We now solve the problem step by step. The full program with fewer comments is found in the final <a href="#porous-media-plain-program">section</a></p><p>Required packages</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors
using FerriteAssembly, FerriteProblems, FerriteNeumann, FESolvers
using MaterialModelsBase
import FerriteProblems as FP
import MaterialModelsBase as MMB</code></pre><h2 id="Physics"><a class="docs-heading-anchor" href="#Physics">Physics</a><a id="Physics-1"></a><a class="docs-heading-anchor-permalink" href="#Physics" title="Permalink"></a></h2><h3 id="Elastic-material"><a class="docs-heading-anchor" href="#Elastic-material">Elastic material</a><a id="Elastic-material-1"></a><a class="docs-heading-anchor-permalink" href="#Elastic-material" title="Permalink"></a></h3><p>For the elastic material, we just define the material following the <code>MaterialModelsBase.jl</code> interface:</p><pre><code class="language-julia hljs">struct Elastic{T} &lt;: AbstractMaterial
    G::T
    K::T
    E4::SymmetricTensor{4,2,T,9}
end
function Elastic(;E=2.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    E4 = 2G*I4dev + K*I4vol
    return Elastic(G, K, E4)
end;

function MMB.material_response(m::Elastic, ϵ, args...; kwargs...)
    σ = m.E4 ⊡ ϵ
    return σ, m.E4, NoMaterialState()
end;</code></pre><h3 id="Poroelastic-material"><a class="docs-heading-anchor" href="#Poroelastic-material">Poroelastic material</a><a id="Poroelastic-material-1"></a><a class="docs-heading-anchor-permalink" href="#Poroelastic-material" title="Permalink"></a></h3><p>For the poroelastic material, we reuse the elastic part from above, but add additionally required properties</p><pre><code class="language-julia hljs">struct PoroElastic{E&lt;:Elastic,T}
    elastic::E
    k::T    # [mm^4/Ns] Permeability
    α::T    # [-] Biot&#39;s coefficient
    β::T    # [1/MPa] Liquid bulk modulus
end
function PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)
    return PoroElastic(elastic, k, α, β)
end;</code></pre><p>And then we also have to define the specific element routine which we do by defining the residual and using autodiff to calculate the tangent</p><pre><code class="language-julia hljs">function FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, dh_fh, Δt, buffer)
    # Setup cellvalues and give easier names
    cv_u = cv[:u]
    cv_p = cv[:p]
    num_u = getnbasefunctions(cv_u)
    num_p = getnbasefunctions(cv_p)

    # Assign views to the matrix and vector parts
    ae_old = FerriteAssembly.get_aeold(buffer)
    udofs = dof_range(dh_fh, :u)
    pdofs = dof_range(dh_fh, :p)
    ru = @view re[udofs]
    rp = @view re[pdofs]
    ue = @view ae[udofs]
    pe = @view ae[pdofs]
    ue_old = @view ae_old[udofs]
    pe_old = @view ae_old[pdofs]

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        # Calculate variables in the current quadrature point
        dΩ = getdetJdV(cv_u, q_point)
        ϵ = function_symmetric_gradient(cv_u, q_point, ue)
        ϵ_old = function_symmetric_gradient(cv_u, q_point, ue_old)
        p = function_value(cv_p, q_point, pe)
        p_old = function_value(cv_p, q_point, pe_old)
        ∇p = function_gradient(cv_p, q_point, pe)
        pdot = (p-p_old)/Δt
        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt
        σeff = material.elastic.E4 ⊡ ϵ

        # Assemble residual contributions
        for iᵤ in 1:num_u
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)
            div_δNu = shape_divergence(cv_u, q_point, iᵤ)
            ru[iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ
        end
        for iₚ in 1:num_p
            δNp = shape_value(cv_p, q_point, iₚ)
            ∇δNp = shape_gradient(cv_p, q_point, iₚ)
            rp[iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ
        end
    end
end;</code></pre><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><h3 id="Mesh-import"><a class="docs-heading-anchor" href="#Mesh-import">Mesh import</a><a id="Mesh-import-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import" title="Permalink"></a></h3><p>In this example, we import the mesh from the Abaqus input file, <a href="porous_media_0p75.inp"><code>porous_media_0p75.inp</code></a> using <code>FerriteMeshParser</code>&#39;s <code>get_ferrite_grid</code> function. (A finer mesh, <a href="porous_media_0p25.inp"><code>porous_media_0p25.inp</code></a>, is also available) We then create one cellset for each phase (solid and porous) for each element type. These 4 sets will later be used in their own <code>FieldHandler</code></p><pre><code class="language-julia hljs">function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media&quot;, &quot;porous_media_0p75.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))

    # Create faceset for the sides and top
    addfaceset!(grid, &quot;sides&quot;, x-&gt;(first(x) &lt; eps() || first(x) ≈ 5.0))
    addfaceset!(grid, &quot;top&quot;, x-&gt;(last(x) ≈ 10.0))
    return grid
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_grid (generic function with 1 method)</code></pre><h3 id="Problem-setup"><a class="docs-heading-anchor" href="#Problem-setup">Problem setup</a><a id="Problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-setup" title="Permalink"></a></h3><p>Define the finite element interpolation, integration, and boundary conditions.</p><pre><code class="language-julia hljs">function create_definition(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()
    ip4_lin = Lagrange{dim, RefCube, 1}()
    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()
    ip4_quad = Lagrange{dim, RefCube, 2}()
    qr3 = QuadratureRule{dim, RefTetrahedron}(1)
    qr4 = QuadratureRule{dim, RefCube}(2)

    # Setup the MixedDofHandler
    dh = MixedDofHandler(grid)
    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,&quot;solid3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,&quot;solid4&quot;)))
    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,&quot;porous3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,&quot;porous4&quot;)))
    close!(dh)

    # Setup cellvalues with the same order as the FieldHandlers in the dh
    # - Linear displacement elements in the solid domain
    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain
    cv = ( CellVectorValues(qr3, ip3_lin),
           CellVectorValues(qr4, ip4_lin),
           (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin)),
           (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin)) )

    # Add boundary conditions
    # Use `Ferrite.jl` PR427 (temporarily included in FerriteProblems.jl)
    # to make Dirichlet conditions easier and more general
    ch = ConstraintHandler(dh);
    # Fix bottom in y and sides in x
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{1}), [2]))
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;sides&quot;), (x,t) -&gt; zero(Vec{1}), [1]))
    # Zero pressure on top surface
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top&quot;), (x,t) -&gt; 0.0))
    close!(ch)

    # Add Neumann boundary conditions - normal traction on top
    nh = NeumannHandler(dh);
    add!(nh, Neumann(:u, 2, getfaceset(grid, &quot;top&quot;), (x,t,n) -&gt; -n*clamp(t/t_rise,0,1)*p_max))

    # We then need one material per fieldhandler:
    materials = (Elastic(), Elastic(), PoroElastic(), PoroElastic())

    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=materials, cc=FP.RelativeResidualElementScaling())
end;</code></pre><h2 id="Postprocessing"><a class="docs-heading-anchor" href="#Postprocessing">Postprocessing</a><a id="Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct PostProcess{PVD}
    pvd::PVD
    filestem::String
end
function PostProcess(filestem=&quot;porous_media&quot;)
    pvd = paraview_collection(&quot;$filestem.pvd&quot;)
    return PostProcess(pvd, filestem)
end

function FESolvers.postprocess!(post::PostProcess, p, step, solver)
    vtk_grid(&quot;$(post.filestem)-$step&quot;, FP.getdh(p)) do vtk
        vtk_point_data(vtk, FP.getdh(p), FP.getunknowns(p))
        vtk_save(vtk)
        post.pvd[step] = vtk
    end
end

FP.close_postprocessing(post::PostProcess, args...) = vtk_save(post.pvd);</code></pre><h2 id="Solving"><a class="docs-heading-anchor" href="#Solving">Solving</a><a id="Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Solving" title="Permalink"></a></h2><p>We solve the problem by using linearly increasing time steps</p><pre><code class="language-julia hljs">problem = FerriteProblem(create_definition(), PostProcess())
solver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x-&gt;x^2, range(0, 1, 41))))
solve_problem!(problem, solver)</code></pre><h2 id="porous-media-plain-program"><a class="docs-heading-anchor" href="#porous-media-plain-program">Plain program</a><a id="porous-media-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#porous-media-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../porous_media.jl"><code>porous_media.jl</code></a>.</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors
using FerriteAssembly, FerriteProblems, FerriteNeumann, FESolvers
using MaterialModelsBase
import FerriteProblems as FP
import MaterialModelsBase as MMB

struct Elastic{T} &lt;: AbstractMaterial
    G::T
    K::T
    E4::SymmetricTensor{4,2,T,9}
end
function Elastic(;E=2.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    E4 = 2G*I4dev + K*I4vol
    return Elastic(G, K, E4)
end;

function MMB.material_response(m::Elastic, ϵ, args...; kwargs...)
    σ = m.E4 ⊡ ϵ
    return σ, m.E4, NoMaterialState()
end;

struct PoroElastic{E&lt;:Elastic,T}
    elastic::E
    k::T    # [mm^4/Ns] Permeability
    α::T    # [-] Biot&#39;s coefficient
    β::T    # [1/MPa] Liquid bulk modulus
end
function PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)
    return PoroElastic(elastic, k, α, β)
end;

function FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, dh_fh, Δt, buffer)
    # Setup cellvalues and give easier names
    cv_u = cv[:u]
    cv_p = cv[:p]
    num_u = getnbasefunctions(cv_u)
    num_p = getnbasefunctions(cv_p)

    # Assign views to the matrix and vector parts
    ae_old = FerriteAssembly.get_aeold(buffer)
    udofs = dof_range(dh_fh, :u)
    pdofs = dof_range(dh_fh, :p)
    ru = @view re[udofs]
    rp = @view re[pdofs]
    ue = @view ae[udofs]
    pe = @view ae[pdofs]
    ue_old = @view ae_old[udofs]
    pe_old = @view ae_old[pdofs]

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        # Calculate variables in the current quadrature point
        dΩ = getdetJdV(cv_u, q_point)
        ϵ = function_symmetric_gradient(cv_u, q_point, ue)
        ϵ_old = function_symmetric_gradient(cv_u, q_point, ue_old)
        p = function_value(cv_p, q_point, pe)
        p_old = function_value(cv_p, q_point, pe_old)
        ∇p = function_gradient(cv_p, q_point, pe)
        pdot = (p-p_old)/Δt
        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt
        σeff = material.elastic.E4 ⊡ ϵ

        # Assemble residual contributions
        for iᵤ in 1:num_u
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)
            div_δNu = shape_divergence(cv_u, q_point, iᵤ)
            ru[iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ
        end
        for iₚ in 1:num_p
            δNp = shape_value(cv_p, q_point, iₚ)
            ∇δNp = shape_gradient(cv_p, q_point, iₚ)
            rp[iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ
        end
    end
end;

function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media&quot;, &quot;porous_media_0p75.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))

    # Create faceset for the sides and top
    addfaceset!(grid, &quot;sides&quot;, x-&gt;(first(x) &lt; eps() || first(x) ≈ 5.0))
    addfaceset!(grid, &quot;top&quot;, x-&gt;(last(x) ≈ 10.0))
    return grid
end

function create_definition(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()
    ip4_lin = Lagrange{dim, RefCube, 1}()
    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()
    ip4_quad = Lagrange{dim, RefCube, 2}()
    qr3 = QuadratureRule{dim, RefTetrahedron}(1)
    qr4 = QuadratureRule{dim, RefCube}(2)

    # Setup the MixedDofHandler
    dh = MixedDofHandler(grid)
    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,&quot;solid3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,&quot;solid4&quot;)))
    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,&quot;porous3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,&quot;porous4&quot;)))
    close!(dh)

    # Setup cellvalues with the same order as the FieldHandlers in the dh
    # - Linear displacement elements in the solid domain
    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain
    cv = ( CellVectorValues(qr3, ip3_lin),
           CellVectorValues(qr4, ip4_lin),
           (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin)),
           (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin)) )

    # Add boundary conditions
    # Use `Ferrite.jl` PR427 (temporarily included in FerriteProblems.jl)
    # to make Dirichlet conditions easier and more general
    ch = ConstraintHandler(dh);
    # Fix bottom in y and sides in x
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{1}), [2]))
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;sides&quot;), (x,t) -&gt; zero(Vec{1}), [1]))
    # Zero pressure on top surface
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top&quot;), (x,t) -&gt; 0.0))
    close!(ch)

    # Add Neumann boundary conditions - normal traction on top
    nh = NeumannHandler(dh);
    add!(nh, Neumann(:u, 2, getfaceset(grid, &quot;top&quot;), (x,t,n) -&gt; -n*clamp(t/t_rise,0,1)*p_max))

    # We then need one material per fieldhandler:
    materials = (Elastic(), Elastic(), PoroElastic(), PoroElastic())

    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=materials, cc=FP.RelativeResidualElementScaling())
end;

struct PostProcess{PVD}
    pvd::PVD
    filestem::String
end
function PostProcess(filestem=&quot;porous_media&quot;)
    pvd = paraview_collection(&quot;$filestem.pvd&quot;)
    return PostProcess(pvd, filestem)
end

function FESolvers.postprocess!(post::PostProcess, p, step, solver)
    vtk_grid(&quot;$(post.filestem)-$step&quot;, FP.getdh(p)) do vtk
        vtk_point_data(vtk, FP.getdh(p), FP.getunknowns(p))
        vtk_save(vtk)
        post.pvd[step] = vtk
    end
end

FP.close_postprocessing(post::PostProcess, args...) = vtk_save(post.pvd);

problem = FerriteProblem(create_definition(), PostProcess())
solver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x-&gt;x^2, range(0, 1, 41))))
solve_problem!(problem, solver)

# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../incompressible_elasticity/">« Incompressible Elasticity</a><a class="docs-footer-nextpage" href="../../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 23 April 2023 17:49">Sunday 23 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
