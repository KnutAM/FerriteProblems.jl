var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"traction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    E = 200.0e9\n    material = J2Plasticity(E, 0.3, 200.e6, E/20)\n\n    # Mesh\n    L = 10.0; w = 1.0; h = 1.0  # Dimensions\n    n = 2\n    nels = (10n, n, 2n)\n    P1 = Vec((0.0, 0.0, 0.0))\n    P2 = Vec((L, w, h))\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n\n    # Interpolation and integration => FEValues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for displacements)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues\n    cv = CellVectorValues(qr, interpolation, interpolation_geom)\n    fv = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    # Degrees of freedom\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, interpolation) # add a displacement field with 3 components\n    close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = [ [J2PlasticityMaterialState() for _ in 1:getnquadpoints(cv)] for _ in 1:getncells(grid)]\n\n\n    return FEDefinition(dh, ch, nh, cv, material, states)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, we need to define the element routine, following FerriteAssemblys interface. This function is almost equivalent to the assemble_cell! in the original example, except that","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We don't have to reinit! as FerriteAssembly does that before calling\nThe traction is handled by FerriteNeumann and is not done for each cell","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector,\n    ue::AbstractVector, ae_old::AbstractVector,\n    state::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend;\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"At this point, we can define problem = FerriteProblem(setup_problem_definition()), which can be solved with FESolvers.jl's solve_problem!. But to get any results apart from the final state, we need to define the postprocessing after each step.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. Since the FerriteProblem type is used for all types of problems, it can be useful to dispatch on the contained postprocessing type to have multiple problems defined in the same session/package.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(p::FerriteProblem{<:PlasticityPostProcess}, step, solver)\n    # First, we save some values directly in the `post` struct\n    push!(p.post.tmag, traction_function(FerriteProblems.gettime(p)))\n    push!(p.post.umag, maximum(abs, FESolvers.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FerriteProblems.addstep!(p.io, FerriteProblems.gettime(p))\n    # * Save the dof values (only displacments in this case)\n    FerriteProblems.savedofdata!(p.io, FESolvers.getunknowns(p))\n    # * Save the state in each integration point\n    FerriteProblems.saveipdata!(p.io, FerriteProblems.getstate(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First, we define a helper function to plot the results after the solution","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem::FerriteProblem{<:PlasticityPostProcess}; plt=plot(), label=nothing, markershape=:auto, markersize=4)\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Temporary: Wrap solve_problem! to make it save any open stuff at the end, even in case of an exception. This is temporary, but would be nice to handle within FESolvers","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function wrapped_solve!(solver, problem)\n    try\n        solve_problem!(solver, problem)\n    finally\n        FerriteProblems.close_problem(problem)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function example_solution()\n    def = setup_problem_definition()\n    makeproblem(_def, folder) = FerriteProblem(_def, PlasticityPostProcess(), joinpath(pwd(), folder))\n\n    # Fixed uniform time steps\n    problem = makeproblem(def, \"A\")\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    wrapped_solve!(solver, problem)\n\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results\n    problem = makeproblem(def, \"A\")\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    wrapped_solve!(solver, problem)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    problem = makeproblem(def, \"B\")\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    wrapped_solve!(solver, problem)\n\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann\n\ninclude(\"J2Plasticity.jl\");\n\ntraction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    E = 200.0e9\n    material = J2Plasticity(E, 0.3, 200.e6, E/20)\n\n    # Mesh\n    L = 10.0; w = 1.0; h = 1.0  # Dimensions\n    n = 2\n    nels = (10n, n, 2n)\n    P1 = Vec((0.0, 0.0, 0.0))\n    P2 = Vec((L, w, h))\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n\n    # Interpolation and integration => FEValues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    # setup quadrature rules\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n\n    # create geometric interpolation (use the same as for displacements)\n    interpolation_geom = Lagrange{3,RefTetrahedron,1}()\n\n    # cell and facevalues\n    cv = CellVectorValues(qr, interpolation, interpolation_geom)\n    fv = FaceVectorValues(face_qr, interpolation, interpolation_geom)\n\n    # Degrees of freedom\n    dh = DofHandler(grid)\n    push!(dh, :u, 3, interpolation) # add a displacement field with 3 components\n    close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = [ [J2PlasticityMaterialState() for _ in 1:getnquadpoints(cv)] for _ in 1:getncells(grid)]\n\n\n    return FEDefinition(dh, ch, nh, cv, material, states)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector,\n    ue::AbstractVector, ae_old::AbstractVector,\n    state::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:i # loop only over lower half\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend;\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(p::FerriteProblem{<:PlasticityPostProcess}, step, solver)\n    # First, we save some values directly in the `post` struct\n    push!(p.post.tmag, traction_function(FerriteProblems.gettime(p)))\n    push!(p.post.umag, maximum(abs, FESolvers.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FerriteProblems.addstep!(p.io, FerriteProblems.gettime(p))\n    # * Save the dof values (only displacments in this case)\n    FerriteProblems.savedofdata!(p.io, FESolvers.getunknowns(p))\n    # * Save the state in each integration point\n    FerriteProblems.saveipdata!(p.io, FerriteProblems.getstate(p), \"state\")\nend;\n\nfunction plot_results(problem::FerriteProblem{<:PlasticityPostProcess}; plt=plot(), label=nothing, markershape=:auto, markersize=4)\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\nfunction wrapped_solve!(solver, problem)\n    try\n        solve_problem!(solver, problem)\n    finally\n        FerriteProblems.close_problem(problem)\n    end\nend;\n\nfunction example_solution()\n    def = setup_problem_definition()\n    makeproblem(_def, folder) = FerriteProblem(_def, PlasticityPostProcess(), joinpath(pwd(), folder))\n\n    # Fixed uniform time steps\n    problem = makeproblem(def, \"A\")\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    wrapped_solve!(solver, problem)\n\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results\n    problem = makeproblem(def, \"A\")\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    wrapped_solve!(solver, problem)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    problem = makeproblem(def, \"B\")\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    wrapped_solve!(solver, problem)\n\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the FESolvers.jl package with Ferrite.jl, as well as the supporting packages  FerriteAssembly.jl and  FerriteNeumann.jl.  It is primarily intended for my own usage:  frequent API changes are expected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides the FerriteProblem type","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct FerriteProblem{POST,DEF,BUF,IOT}\n    def::DEF\n    post::POST\n    buf::BUF\n    io::IOT\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"with FerriteProblem(def, post=nothing, io=nothing) as constructor.  The four parts have distinct tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"def::FEDefinition is responsible for the full problem definition.  I.e., given def, the full simulation should be possible to replicate,  given the same solver from FESolvers.jl\npost contains all information related to the postprocessing of each step.  This typically varies a lot between simulations,  and is the first type parameter to allow easy  dispatch on problems with different posts.  \nbuf::FEBuffer contains all buffer values,  these are not necessary (nor desirable) to save,  and can be recreated each time the constructor is called.\nio::FerriteIO: This field enable file handling to allow easy saving  and retrieving of results from a simulation using JLD2 files.","category":"page"}]
}
