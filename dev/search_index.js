var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This example is the adoption of Ferrite.jls example To adapt, we make a few changes, specifically that we don't use BlockArrays","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The full code, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteNeumann, FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA","category":"page"},{"location":"examples/incompressible_elasticity/#Problem-setup","page":"Incompressible Elasticity","title":"Problem setup","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We also need to add Dirichlet boundary conditions on the \"clamped\" faceset. We specify a homogeneous Dirichlet bc on the displacement field, :u.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Define a cache for the material, as used in the original example","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function FP.allocate_material_cache(::LinearElasticity, cv::NamedTuple)\n    cellvalues_u = cv[:u]\n    return collect([symmetric(shape_gradient(cellvalues_u, 1, i)) for i in 1:getnbasefunctions(cellvalues_u)])\nend\n\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = create_bc(dh)\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=m)\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Physics-(element-routine)","page":"Incompressible Elasticity","title":"Physics (element routine)","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We define the element according to FerriteAssembly, and without any Neumann contributions. We restrict this element to only work with FESolvers.LinearProblemSolver by not including the internal forces in residual. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, dh_fh, Δt, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    # Create views of the different fields\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    Ke_uu = @view Ke[udofs,udofs]\n    Ke_pu = @view Ke[pdofs,udofs]\n    Ke_pp = @view Ke[pdofs,pdofs]\n\n    # Extract cached gradients\n    ∇Nu_sym_dev = FA.get_cache(buffer)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            for j in 1:i\n                Ke_uu[i,j] += 2 * mp.G * ∇Nu_sym_dev[i] ⊡ ∇Nu_sym_dev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δNp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδNu = shape_divergence(cellvalues_u, q_point, j)\n                Ke_pu[i,j] += -δNp * divδNu * dΩ\n            end\n            for j in 1:i\n                Np = shape_value(cellvalues_p, q_point, j)\n                Ke_pp[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Postprocessing","page":"Incompressible Elasticity","title":"Postprocessing","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    dh = FP.getdh(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Solving-the-problem","page":"Incompressible Elasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(p1, solver)\nsolve_problem!(p2, solver)","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Here follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteNeumann, FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend\n\nfunction FP.allocate_material_cache(::LinearElasticity, cv::NamedTuple)\n    cellvalues_u = cv[:u]\n    return collect([symmetric(shape_gradient(cellvalues_u, 1, i)) for i in 1:getnbasefunctions(cellvalues_u)])\nend\n\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = create_bc(dh)\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=m)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, dh_fh, Δt, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    # Create views of the different fields\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    Ke_uu = @view Ke[udofs,udofs]\n    Ke_pu = @view Ke[pdofs,udofs]\n    Ke_pp = @view Ke[pdofs,pdofs]\n\n    # Extract cached gradients\n    ∇Nu_sym_dev = FA.get_cache(buffer)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            for j in 1:i\n                Ke_uu[i,j] += 2 * mp.G * ∇Nu_sym_dev[i] ⊡ ∇Nu_sym_dev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δNp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδNu = shape_divergence(cellvalues_u, q_point, j)\n                Ke_pu[i,j] += -δNp * divδNu * dΩ\n            end\n            for j in 1:i\n                Np = shape_value(cellvalues_p, q_point, j)\n                Ke_pp[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nstruct PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    dh = FP.getdh(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\n\nfunction build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(p1, solver)\nsolve_problem!(p2, solver)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteNeumann, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr();\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file. We have modified the names and functions to comply with MaterialModelsBase.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This file defines the","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"J2Plasticity<:AbstractMaterial material type with the constructor J2Plasticity(E,ν,σy0,H)\nState variable struct J2PlasticityMaterialState<:AbstractMaterialState\nThe MaterialModelsBase function initial_material_state and material_response","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For a single material according to the MaterialModelsBase interface, FerriteAssembly.element_routine! and FerriteAssembly.create_cell_state are already included in FerriteProblems, see src/MaterialModelsBase.jl.","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"traction_function(t) = Vec{3}((0.0, 0.0, t*1.e7)) # N/m²\ntraction_function(x, t, n) =  traction_function(t)\n\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # CellValues\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}())\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zero(Vec{3})), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions (`FerriteNeumann.jl`)\n    nh = NeumannHandler(dh)\n    quad_order = 3\n    add!(nh, Neumann(:u, quad_order, getfaceset(grid, \"right\"), traction_function))\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, we need to define the element routine, following FerriteAssemblys interface. This function is almost equivalent to the assemble_cell! in the original example, except that","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We don't have to reinit! as FerriteAssembly does that before calling\nThe traction is handled by FerriteNeumann and is not done for each cell","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For convenience, this element is already implemented for materials of MaterialModelsBase type AbstractMaterial, and we don't need to define it here.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. Note that, internally, FerriteProblems imports the FESolvers functions getunknowns, getjacobian, and getresidual, such that you can access these via FerriteProblems. (or FP. if using the import FerriteProblems as FP above). For convenience, FerriteProblems will call FESolvers.postprocess! with the post as the first argument making it easy to dispatch on:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p))[3])\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We also define a helper function to plot the results after completion","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(post::PlasticityPostProcess;\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, post.umag)\n    tmag = vcat(0.0, post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results. Here, we use FerriteProblems' safesolve that (1) creates our full problem::FerriteProblem and (2) ensures that files are closed even when the problem doesn't converge.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"global umax_solution = [0.0] # To save result for test #hide\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem.post, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"fixed\", markershape=:circle)\n    umax_solution[1] = problem.post.umag[end] # Save value for comparison  #hide\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\nusing Test # Compare to Ferrite.jl's example #hide\n@test isapprox(umax_solution[1], 0.254452; rtol=1.e-4);  #hide\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteNeumann, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr();\n\ninclude(\"J2Plasticity.jl\");\n\ntraction_function(t) = Vec{3}((0.0, 0.0, t*1.e7)) # N/m²\ntraction_function(x, t, n) =  traction_function(t)\n\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # CellValues\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}())\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zero(Vec{3})), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions (`FerriteNeumann.jl`)\n    nh = NeumannHandler(dh)\n    quad_order = 3\n    add!(nh, Neumann(:u, quad_order, getfaceset(grid, \"right\"), traction_function))\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material)\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p))[3])\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\n\nfunction plot_results(post::PlasticityPostProcess;\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, post.umag)\n    tmag = vcat(0.0, post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem.post, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(problem, solver)\n    plot_results(problem.post, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main types below are exported.  Remaining functions are not exported to avoid polluting the  name space. Tip: To simplify calling the following functions it is possible to write import FerriteProblems as FP as is done in the examples. ","category":"page"},{"location":"api/#Main-types","page":"API","title":"Main types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblem\nFEDefinition\nFerriteIO","category":"page"},{"location":"api/#FerriteProblems.FerriteProblem","page":"API","title":"FerriteProblems.FerriteProblem","text":"FerriteProblem(def::FEDefinition, post, buf::FEBuffer, io::[FerriteIO])\n\nThe main problem type that holds all variables to solve a particular problem  using FESolvers\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FEDefinition","page":"API","title":"FerriteProblems.FEDefinition","text":"FEDefinition(dh, ch, nh, cv, m, bl, initialstate, ic)\nFEDefinition(;\n    dh, ch, cv, m,\n    nh=NeumannHandler(dh), bl=nothing, ic=(), \n    initialstate=_create_states(dh,m,cv,ic),\n    cc=AbsoluteResidual(), colors=nothing,\n    )\n\nThe definition of the FE-problem, this data describes the finite  element problem as a function of time. For how long to run and how  to step through time is typically done by FESolvers.jl. \n\nFields/inputs\n\nSee more information below for items marked with *\n\ndh: The dof handler, Union{DofHandler,MixedDofHandler} (Ferrite.jl)\nch: The constraint handler, ConstraintHandler (Ferrite.jl)\nnh: The neumann bc handler, NeumannHandler (FerriteNeumann.jl)\ncv: The cellvalues, e.g. CellValues (*)\nm: The material definition, user defined type - passed into element. (*)\nbl: Source term/body load, user defined type - available from the element routine (*)\nic: Initial conditions. NamedTuple with a function f(x) for each field that has a nonzero  initial condition. Used by the Ferrite.jl's apply_analytical! function  (included here if Ferrite version too old).\ninitialstate: The initial state variables for each cell in the grid. By default, this is  automatically created by FerriteAssembly.create_states with customization provided by overloading FerriteAssembly.create_cell_state and is not necessary to supply here. \ncc::ConvergenceCriterion: Determines how to calculate the convergence measure including scaling\ncolors: Supply to use threaded assembly, can be created by Ferrite.create_coloring\n\nMixedDofHandler\n\nWhen the MixedDofHandler is used, we have an outer loop over each of its FieldHandlers. Therefore, cv, m, and bl may be provided for each of these fields by providing them as  a tuple. Otherwise, they are duplicated for each field (by reference)\n\ninitialstate must be a tuple containing Dict{Int} with states for the cells in the relevant  FieldHandler's cellset. \n\nMultiple CellValues for each element In coupled problems, each element might require multiple CellValues.  If the same should be used for all fields (even if only one FieldHandler),  a NamedTuple is the easiest (the alternative is a Tuple of Tuples).  If different multiple CellValues should be used for each field, then pass as  Tuple of NamedTuple/Tuple\n\nMultiple materials\n\nNote: The following setup is not needed if you have one material for each FieldHandler when using a MixedDofHandler\n\nIf you want to have different materials on different parts of the grid,  you should first define those cellsets, and then define each material  as a value of m::Dict{String} with the name of the cellset as key. \n\nYou may do the same for bl and cv.  Otherwise, the same values will be used for every cellset. \n\nCombine with MixedDofHandler:  Follow the required input for MixedDofHandler,  but wrap items (at least the material and initialstate) in Dicts as described above\n\nState variables:  initialstate::Dict{String} must mirror the datastructure of m::Dict{String}: For each key in m::Dict{String}, initialstate[key] holds a collection of states  for the cells in getcellset(dh,key).\n\nIf MixedDofHandler, then initialstate[key]::NTuple{N,<:Dict{Int}},  and if DofHandler, then initialstate[key]::Dict{Int}\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FerriteIO","page":"API","title":"FerriteProblems.FerriteIO","text":"FerriteIO(\n    folder::String, def::FEDefinition, post=nothing; \n    def_file=\"FEDefinition.jld2\", \n    postfile=\"FEPost.jld2\",\n    T=Float64, \n    nsteps_per_file=typemax(Int), \n    switchsize=Inf\n    )\n\nConstructor for creating a FerriteIO when simulating. \n\n\n\n\n\nFerriteIO(filename::String)\n\nConstructor for reading a FerriteIO that was saved during a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#Setting-up-simulation","page":"API","title":"Setting up simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.cellbuffertype\nFerriteProblems.allocate_material_cache","category":"page"},{"location":"api/#FerriteProblems.cellbuffertype","page":"API","title":"FerriteProblems.cellbuffertype","text":"cellbuffertype(def)\n\nBy default, cellbuffertype(::Any) = CellBuffer.  However, if you are using the automatic differentiation,  much better assembly speed can be achieved by defining\n\nFerriteProblems.cellbuffertype(::FEDefinition) = AutoDiffCellBuffer\n\nIn this case, any defined element_routine! should  use getCellBuffer(buffer) to get a CellBuffer instead  of AutoDiffCellBuffer.  This is not necessary in element_residual!\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.allocate_material_cache","page":"API","title":"FerriteProblems.allocate_material_cache","text":"FerriteProblems.allocate_material_cache(material, cellvalues)\n\nIn case the material requires a cache to be available during the element routine, this function can be overloaded for the specific material to define such a cache to be included in the FerriteAssembly.CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#Convergence-criteria","page":"API","title":"Convergence criteria","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In normal usage, the following convergence criteria can be used","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.ConvergenceCriterion\nFerriteProblems.AbsoluteResidual\nFerriteProblems.RelativeResidualElementScaling","category":"page"},{"location":"api/#FerriteProblems.ConvergenceCriterion","page":"API","title":"FerriteProblems.ConvergenceCriterion","text":"ConvergenceCriterion\n\nThe abstract type ConvergenceCriterion is the supertype for all  convergence criteria. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.AbsoluteResidual","page":"API","title":"FerriteProblems.AbsoluteResidual","text":"AbsoluteResidual()\n\nThe default convergence criterion that calculates the convergence measure as  √(sum([r[i]^2 for i ∈ free dofs]) without any scaling. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.RelativeResidualElementScaling","page":"API","title":"FerriteProblems.RelativeResidualElementScaling","text":"RelativeResidualElementScaling(p, minfactors::Union{AbstractFloat,NamedTuple}=eps())\n\nUse Ferriteassembly.ElementResidualScaling with the exponent p to calculate the  scaling for each field individually, based on the L2-norm of each cell's residual.  To avoid issues when all cells have zero residual (e.g. in the first time step), supply minfactors as the minimum scaling factor.  The convergence measure is calculated with the following pseudo-code\n\nval = 0.0\nfor field in Ferrite.getfieldnames(dh)\n    factor = max(element_residual_scaling[field], minfactors[field])\n    dofs = free_field_dofs[field]   # Get the non-constrained dofs for `field`\n    val += sum(i->(r[i]/factor)^2, dofs)\nend\nreturn √val\n\nwhere the same minfactor is used for all fields if only a scalar value is given. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"To create custom convergence criteria, the following functions  may require overloading. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.TolScaling\nFerriteProblems.make_assemscaling\nFESolvers.calculate_convergence_measure","category":"page"},{"location":"api/#FerriteProblems.TolScaling","page":"API","title":"FerriteProblems.TolScaling","text":"TolScaling(criterion::ConvergenceCriterion, def::FEDefinition)\n\nThe TolScaling type contains the criterion that determines how to scale the residuals to determine  convergence. The constructor is specialized on typeof(criterion), creating the following fields:\n\nassemscaling: Used in FerriteAssembly.doassemble! to give potential scaling contribution based on each element's residual\nbuffer: Used to pre-calculate values, such as dof-ranges for each field that is used when calculating the convergence measure. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.make_assemscaling","page":"API","title":"FerriteProblems.make_assemscaling","text":"make_assemscaling(criterion, def, threaded::Val{false})\n\nCreate the actual assemscaling for the given criterion.\n\nmake_assemscaling(criterion, def, threaded::Val{true})\n\nIf threaded::Val{true}, then call make_assemscaling(criterion, def, ::Val{false})  for each thread to support threaded assembly. Note that the function has a definition  make_assemscaling(criterion,def)=make_assemscaling(criterion,def,dothreaded(def)) to simplify calling it. If required, a criterion should overload make_assemscaling(criterion,def,::Val{false}). The default, if not overloaded, returns nothing.  That suffices if nothing needs to be calculated for each cell during assembly. \n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.calculate_convergence_measure","page":"API","title":"FESolvers.calculate_convergence_measure","text":"FESolvers.calculate_convergence_measure(::ConvergenceCriterion, scaling::TolScaling, r::Vector, Δa, iter, p::FerriteProblem)\n\nSpecialize this function for each ConvergenceCriterion. Note this function is called via the definition\n\ncalculate_convergence_measure(ts::TolScaling, args...) = calculate_convergence_measure(ts.criterion, ts, args...)\n\n\n\n\n\n","category":"function"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.getdh\nFerriteProblems.getch\nFerriteProblems.getnh\nFerriteProblems.getcv\nFerriteProblems.getmaterial\nFerriteProblems.getbodyload\nFerriteProblems.getjacobian\nFerriteProblems.getunknowns\nFerriteProblems.getresidual\nFerriteProblems.getneumannforce\nFerriteProblems.getoldunknowns\nFerriteProblems.getstate\nFerriteProblems.getoldstate\nFerriteProblems.gettime\nFerriteProblems.getoldtime","category":"page"},{"location":"api/#FerriteProblems.getdh","page":"API","title":"FerriteProblems.getdh","text":"FerriteProblems.getdh(p::FerriteProblem)\n\nGet dh::Ferrite.AbstractDofHandler from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getch","page":"API","title":"FerriteProblems.getch","text":"FerriteProblems.getch(p::FerriteProblem)\n\nGet the ConstraintHandler from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnh","page":"API","title":"FerriteProblems.getnh","text":"FerriteProblems.getnh(p::FerriteProblem)\n\nGet the NeumannHandler from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcv","page":"API","title":"FerriteProblems.getcv","text":"FerriteProblems.getcv(p::FerriteProblem)\n\nGet the cell values from the FerriteProblem.  Note that this could also be a Tuple or NamedTuple depending on  what was initially given to FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getmaterial","page":"API","title":"FerriteProblems.getmaterial","text":"FerriteProblems.getmaterial(p::FerriteProblem)\n\nGet the material from the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getbodyload","page":"API","title":"FerriteProblems.getbodyload","text":"FerriteProblems.getbodyload(p::FerriteProblem)\n\nGet the bodyload given to the FerriteProblem\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getjacobian","page":"API","title":"FESolvers.getjacobian","text":"FerriteProblems.getjacobian(p::FerriteProblem)\n\nGet the current jacobian matrix from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FerriteProblems.getjacobian\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getunknowns","page":"API","title":"FESolvers.getunknowns","text":"FerriteProblems.getunknowns(p::FerriteProblem)\n\nGet the current vector of unknowns from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FerriteProblems.getunknowns\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getresidual","page":"API","title":"FESolvers.getresidual","text":"FerriteProblems.getresidual(p::FerriteProblem)\n\nGet the current residual vector from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FerriteProblems.getresidual\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getneumannforce","page":"API","title":"FerriteProblems.getneumannforce","text":"FerriteProblems.getneumannforce(p::FerriteProblem)\n\nGet the current external force vector caused by  Neumann boundary conditions. Note that this vector  does not include external forces added during the  cell assembly; only forces added with the NeumannHandler\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldunknowns","page":"API","title":"FerriteProblems.getoldunknowns","text":"FerriteProblems.getoldunknowns(p::FerriteProblem)\n\nGet the vector of unknowns from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getstate","page":"API","title":"FerriteProblems.getstate","text":"FerriteProblems.getstate(p::FerriteProblem)\n\nGet the current state variables\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldstate","page":"API","title":"FerriteProblems.getoldstate","text":"FerriteProblems.getoldstate(p::FerriteProblem)\n\nGet the state variables from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettime","page":"API","title":"FerriteProblems.gettime","text":"FerriteProblems.gettime(p::FerriteProblem)\n\nGet the current time\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldtime","page":"API","title":"FerriteProblems.getoldtime","text":"FerriteProblems.getoldtime(p::FerriteProblem)\n\nGet time of the previous converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#Saving-and-loading-data","page":"API","title":"Saving and loading data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FESolvers.postprocess!\nFerriteProblems.close_postprocessing\nFerriteProblems.addstep!\nFerriteProblems.gettimedata\nFerriteProblems.savedofdata!\nFerriteProblems.getdofdata\nFerriteProblems.savenodedata!\nFerriteProblems.getnodedata\nFerriteProblems.savecelldata!\nFerriteProblems.getcelldata\nFerriteProblems.saveipdata!\nFerriteProblems.getipdata\nFerriteProblems.saveglobaldata!\nFerriteProblems.getglobaldata\nFerriteProblems.getdef\nFerriteProblems.getpost","category":"page"},{"location":"api/#FESolvers.postprocess!","page":"API","title":"FESolvers.postprocess!","text":"FESolvers.postprocess!(p::FerriteProblem, step, solver)\n\nWhen FESolvers call this function for p::FerriteProblem,  the following function\n\nFESolvers.postprocess!(post, p::FerriteProblem, step, solver)\n\nis called where post=p.post (unless you define a different override).  This allows you to easily define the dispatch on your postprocessing  type as FESolvers.postprocess!(post::MyPostType, p, step, solver) Note that the solver input argument is required, but can be  accounted for by defining, e.g.  FESolvers.postprocess!(post::MyPostType, p, step, args...)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.close_postprocessing","page":"API","title":"FerriteProblems.close_postprocessing","text":"close_postprocessing(post::MyPostType, p::FerriteProblem)\n\nThis function is called to close any open files manually created during  the postprocessing with the custom postprocessing type MyPostType.  Note that the file streams in p.io::FerriteIO are  automatically closed and don't require any special handling.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.addstep!","page":"API","title":"FerriteProblems.addstep!","text":"FerriteProblems.addstep!(io::FerriteIO, p::FerriteProblem)\n\nAdd a new step to be saved by io at the time gettime(p) Must be called before adding any new data\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettimedata","page":"API","title":"FerriteProblems.gettimedata","text":"gettimedata(io::FerriteIO)\ngettimedata(io::FerriteIO, step)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savedofdata!","page":"API","title":"FerriteProblems.savedofdata!","text":"FerriteProblems.savedofdata!(io::FerriteIO, vals, dt_order=0, field=\"dof\")\n\nSave data pertaining to each degree of freedom. Use a different field than \"dof\"` to save data located at each dof,  but not the actual dof values (e.g. the residual vector)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdofdata","page":"API","title":"FerriteProblems.getdofdata","text":"FerriteProblems.getdofdata(io::FerriteIO, step, field=\"dof\"; dt_order=0)\n\nGet the data saved by FerriteProblems.savedofdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savenodedata!","page":"API","title":"FerriteProblems.savenodedata!","text":"FerriteProblems.savenodedata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data located at each node. By convention this should be indexed by the node numbers in the grid. (E.g. a Vector for all nodes or a Dict{Int} with keys the node numbers)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnodedata","page":"API","title":"FerriteProblems.getnodedata","text":"FerriteProblems.getnodedata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.savenodedata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savecelldata!","page":"API","title":"FerriteProblems.savecelldata!","text":"FerriteProblems.savecelldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each cell.  By convention this should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcelldata","page":"API","title":"FerriteProblems.getcelldata","text":"FerriteProblems.getcelldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.savecelldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveipdata!","page":"API","title":"FerriteProblems.saveipdata!","text":"FerriteProblems.saveipdata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each integration point in cells in the grid.  By convention the data for each cell should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices) Note that it is on the user to know how the integration points are numbered,  i.e. which QuadratureRule that was used. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getipdata","page":"API","title":"FerriteProblems.getipdata","text":"FerriteProblems.getipdata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.saveipdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveglobaldata!","page":"API","title":"FerriteProblems.saveglobaldata!","text":"FerriteProblems.saveglobaldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data that is global to the entire simulation, i.e. global quantites such as  reaction forces, total dissipation, etc. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getglobaldata","page":"API","title":"FerriteProblems.getglobaldata","text":"FerriteProblems.getglobaldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by FerriteProblems.saveglobaldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdef","page":"API","title":"FerriteProblems.getdef","text":"FerriteProblems.getdef(io::FerriteIO)\n\nLoad the FEDefinition from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getpost","page":"API","title":"FerriteProblems.getpost","text":"FerriteProblems.getpost(io::FerriteIO)\n\nLoad the user defined post from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/transient_heat.jl\"","category":"page"},{"location":"examples/transient_heat/#Linear-Time-Dependent-Problem","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This example is the same example as FESolvers.jl's transient heat flow which was taken from Ferrite.jl's transient heat flow. Please see the theoretical derivations in those examples, with the specific formulation used here in the former.","category":"page"},{"location":"examples/transient_heat/#Commented-Program","page":"Linear Time Dependent Problem","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Now we solve the problem by using FerriteProblems. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First we load required packages","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA","category":"page"},{"location":"examples/transient_heat/#Physics","page":"Linear Time Dependent Problem","title":"Physics","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First, we need to define the material behavior.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Base.@kwdef struct FicksLaw{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"where we could have defined the heat source using the bodyload type available via the cellbuffer, but it is not necessary for a constant heat source.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define element routine following FerriteAssembly","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FicksLaw, cellvalues, dh_fh, Δt, buffer\n    )\n    ue_old = FA.get_aeold(buffer)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#Problem-setup","page":"Linear Time Dependent Problem","title":"Problem setup","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We start by a function that will create the problem definition","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, cv=cellvalues, m=FicksLaw())\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#Postprocessing","page":"Linear Time Dependent Problem","title":"Postprocessing","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"After defining all the physics and problem setup, we must decide what data to save. In this example, we use the vtk-file exports as in the original example. To this end, we define the custom postprocessing struct","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And the postprocessing function that is called after each time step","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    if step < 5 || mod(step, 20) == 0\n        @info \"postprocessing step $step\"\n        dh = FP.getdh(p)\n        vtk_grid(\"transient-heat-$step\", dh) do vtk\n            vtk_point_data(vtk, dh, FP.getunknowns(p))\n            vtk_save(vtk)\n            post.pvd[step] = vtk\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"At the end of the simulation, we want to finish all IO operations. We can then define the function close_postprocessing which will be called even in the case that an error is thrown during the simulation","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FP.close_postprocessing(post::PostProcessing, p)\n    vtk_save(post.pvd)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And now we create the problem type, and define the QuasiStaticSolver with the LinearProblemSolver as well as fixed time steps","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"def = create_definition()\npost = PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Finally, we can solve the problem","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"solve_problem!(problem, solver);\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#transient_heat_equation-plain-program","page":"Linear Time Dependent Problem","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat.jl.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP\nimport FerriteAssembly as FA\n\nBase.@kwdef struct FicksLaw{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FicksLaw, cellvalues, dh_fh, Δt, buffer\n    )\n    ue_old = FA.get_aeold(buffer)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\n\nfunction create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, cv=cellvalues, m=FicksLaw())\nend;\n\nstruct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    if step < 5 || mod(step, 20) == 0\n        @info \"postprocessing step $step\"\n        dh = FP.getdh(p)\n        vtk_grid(\"transient-heat-$step\", dh) do vtk\n            vtk_point_data(vtk, dh, FP.getunknowns(p))\n            vtk_save(vtk)\n            post.pvd[step] = vtk\n        end\n    end\nend;\n\nfunction FP.close_postprocessing(post::PostProcessing, p)\n    vtk_save(post.pvd)\nend;\n\ndef = create_definition()\npost = PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\n\nsolve_problem!(problem, solver);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/io.jl\"","category":"page"},{"location":"examples/io/#IO:-Saving-and-loading-simulations","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"","category":"section"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"The FerriteProblems.jl package includes support for saving simulation data using JLD2.jl. This examples shows some examples of how this can be done. Specifically, we use the data saved during the plasticity example:","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"using Ferrite, FerriteProblems\nimport FerriteProblems as FP\ninclude(\"plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"In that example, the displacements and state variables were saved in each time step. In this example, we use the data saved in the folder B (using the AdaptiveTimeStepper) and plot a few interesting cases:","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Maximum von Mises stress as function of time\nExport the final displacements and stress to vtk","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"We start by loading the results","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"io = FerriteIO(\"B/FerriteIO.jld2\")\ndef = FP.getdef(io)\npost = FP.getpost(io);\nnothing #hide","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Then, we get the time history and the displacement data saved to the post struct","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"t_history = FP.gettimedata(io)\nu_mag = post.umag\n\nplt1 = plot()\nplot!(plt1, t_history, u_mag*1e3)\ntitle!(plt1, \"maximum displacement\")\nxlabel!(plt1, \"time [s]\")\nylabel!(plt1, \"umax [mm]\")\n\ndisplay(plt1)","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"The maximum von Mises stress for each step is calculated next. Note that step refers to the count of saved steps, and not the actual simulation steps.","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"function get_max_vm_stress(step)\n    states = FP.getipdata(io, step, \"state\")\n    σ_vm = maximum(cellstates -> maximum(state -> vonMises(state.σ), cellstates), states)\n    return σ_vm\nend\n\nσ_vm = get_max_vm_stress.(1:length(t_history));\nnothing #hide","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Plot the analyzed results","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"plt2=plot()\nplot!(plt2, t_history, σ_vm*1e-6)\ntitle!(plt2, \"Maximum von Mises stress\")\nxlabel!(plt2, \"time [s]\")\nylabel!(plt2, \"stress [MPa]\")\n\ndisplay(plt2)","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"Finally, we extract the degrees of freedom and the stresses in each element at the last step to save to vtk.","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"step = length(t_history)\nu = FP.getdofdata(io, step)\nstates = FP.getipdata(io, step, \"state\")\ndh = FP.getdh(def)\nmises_values = zeros(getncells(dh.grid))\nfor (el, cell_states) in enumerate(states)\n    for state in cell_states\n        mises_values[el] += vonMises(state.σ)\n    end\n    mises_values[el] /= length(cell_states) # average von Mises stress\nend\nvtk_grid(\"plasticity\", dh) do vtkfile\n    vtk_point_data(vtkfile, dh, u) # displacement field\n    vtk_cell_data(vtkfile, mises_values, \"von Mises [Pa]\")\nend;\nnothing #hide","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"We do need to close any open files from the io object, which we simply do by calling close:","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"close(io)","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"","category":"page"},{"location":"examples/io/","page":"IO: Saving and loading simulations","title":"IO: Saving and loading simulations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the  FESolvers.jl package with  Ferrite.jl, as well as the supporting packages  FerriteAssembly.jl and  FerriteNeumann.jl.  There is also preliminary support for organizing your simulations  by saving both setup and results as .jld2 using JLD2.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"All unregistered dependencies, including FerriteProblems.jl itself,  is available in the knutamregistry","category":"page"},{"location":"","page":"Home","title":"Home","text":"The workflow requires you to create its FerriteProblem type which  can then be solved by FESolvers.jl.  The easiest way to get started is to just follow the examples.  Note that the documentation of Ferrite.jl, FerriteAssembly.jl,  and FerriteNeumann.jl should be considered as well. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct FerriteProblem{POST,DEF,BUF,IOT}\n    def::DEF\n    post::POST\n    buf::BUF\n    io::IOT\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"with FerriteProblem(def, post=nothing, io=nothing) as constructor.  The four parts have distinct tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"def::FEDefinition is responsible for the full problem definition.  I.e., given def, the full simulation should be possible to replicate,  given the same solver from FESolvers.jl\npost contains all information related to the postprocessing of each step.  This typically varies a lot between simulations,  and is the first type parameter to allow easy  dispatch on problems with different posts.  \nbuf::FEBuffer contains all buffer values,  these are not necessary (nor desirable) to save,  and can be recreated each time the constructor is called.\nio::FerriteIO: This field enable file handling to allow easy saving  and retrieving of results from a simulation using JLD2 files.","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note: These functions are not considered \"documented\" and changes here are therefore not considered breaking.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteProblems.FEBuffer\nFerriteProblems.getcellbuffer\nFerriteProblems.get_tolerance_scaling\nFerriteProblems.update_unknowns!\nFerriteProblems.copy_states!\nFerriteProblems.update_states!\nFerriteProblems.reset_states!\nFerriteProblems.settime!\nFerriteProblems.update_time!\nFerriteProblems._create_states\nFerriteProblems.filepath\nFerriteProblems.datafilepath\nFerriteProblems.new_file!\nFerriteProblems.new_file_if_needed!\nFerriteProblems.update_currentsize!\nFerriteProblems.getfilenumber\nFerriteProblems.open_if_needed!\nFerriteProblems.close_io\nFerriteProblems.checkkey\nFerriteProblems.savedata!\nFerriteProblems.getdata\nFerriteProblems.get_dof2node\nFerriteProblems.dothreaded","category":"page"},{"location":"internals/#FerriteProblems.FEBuffer","page":"Internals","title":"FerriteProblems.FEBuffer","text":"FEBuffer(K,x,r,f,xold,cellbuffer,state,old_state,time,old_time)\n\nA buffer to hold all values that are required to simulate,  but that are uniqely defined from the simulation definition\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteProblems.getcellbuffer","page":"Internals","title":"FerriteProblems.getcellbuffer","text":"FerriteProblems.getcellbuffer(p::FerriteProblem)\n\nGet the cell buffers used during the assembly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.get_tolerance_scaling","page":"Internals","title":"FerriteProblems.get_tolerance_scaling","text":"FerriteProblems.get_tolerance_scaling(p::FerriteProblem)\n\nGet the TolScaling type that controls the convergence  measure to be compared with the solver's tolerance\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_unknowns!","page":"Internals","title":"FerriteProblems.update_unknowns!","text":"FerriteProblems.update_unknowns!(p::FerriteProblem)\n\nUpdate the vector of \"old\" unknowns to the values of the current vector of unknowns\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.copy_states!","page":"Internals","title":"FerriteProblems.copy_states!","text":"FerriteProblems.copy_states!(to, from)\n\nPerform a \"deepcopy!\" of states in from into to.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_states!","page":"Internals","title":"FerriteProblems.update_states!","text":"FerriteProblems.update_states!(p::FerriteProblem)\n\nUpdate the \"old\" state variables to the current values. Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.reset_states!","page":"Internals","title":"FerriteProblems.reset_states!","text":"FerriteProblems.reset_states!(p::FerriteProblem)\n\nReset the current state variables to the old state values.  Called after each solution iteration unless the solution has converged. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.settime!","page":"Internals","title":"FerriteProblems.settime!","text":"FerriteProblems.settime!(p::FerriteProblem, new_time)\n\nSet the current time to new_time Called when starting a new step (or when attempting the same  step number with a new time increment)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_time!","page":"Internals","title":"FerriteProblems.update_time!","text":"FerriteProblems.update_time!(p::FerriteProblem)\n\nUpdate the old time to the current time.  Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems._create_states","page":"Internals","title":"FerriteProblems._create_states","text":"_create_states(dh::AbstractDofHandler, material, cellvalues, initial_conditions)\n\nCreate the state variables by calling FerriteAssembly.create_states after calculating  the degree of freedom values with Ferrite.jl's applyanalytical! and the  `initialconditions` input.  \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.filepath","page":"Internals","title":"FerriteProblems.filepath","text":"filepath(io::FerriteIO, args...) = joinpath(io.folder[], args...)\n\nGet the path of a file relative io's folder\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.datafilepath","page":"Internals","title":"FerriteProblems.datafilepath","text":"datafilepath(io::FerriteIO, num=length(io.datafiles))\n\nGet the path of the data file number num in io.datafiles\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file!","page":"Internals","title":"FerriteProblems.new_file!","text":"new_file!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file_if_needed!","page":"Internals","title":"FerriteProblems.new_file_if_needed!","text":"new_file_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_currentsize!","page":"Internals","title":"FerriteProblems.update_currentsize!","text":"update_currentsize!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getfilenumber","page":"Internals","title":"FerriteProblems.getfilenumber","text":"getfilenumber\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.open_if_needed!","page":"Internals","title":"FerriteProblems.open_if_needed!","text":"open_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.close_io","page":"Internals","title":"FerriteProblems.close_io","text":"close_io(io::FerriteIO, post)\n\nClose the currently open file in io, then the postprocessing  struct to a jld2 file (if not post != nothing), before finally saving the current io object to a .jld2 file\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.checkkey","page":"Internals","title":"FerriteProblems.checkkey","text":"checkkey\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.savedata!","page":"Internals","title":"FerriteProblems.savedata!","text":"savedata!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getdata","page":"Internals","title":"FerriteProblems.getdata","text":"getdata\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.get_dof2node","page":"Internals","title":"FerriteProblems.get_dof2node","text":"get_dof2node\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.dothreaded","page":"Internals","title":"FerriteProblems.dothreaded","text":"dothreaded(def::FEDefinition)\n\nTrait-based dispatch to determine if threaded assembly should be used. Returns a Val{t::Bool}. \n\n\n\n\n\n","category":"function"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/porous_media.jl\"","category":"page"},{"location":"examples/porous_media/#Porous-media","page":"Porous media","title":"Porous media","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Porous media is a two-phase material, consisting of solid parts and a liquid occupying the pores inbetween. Using the porous media theory, we can model such a material without explicitly resolving the microstructure, but by considering the interactions between the solid and liquid. In this example, we will additionally consider larger linear elastic solid aggregates that are impermeable. Hence, there is no liquids in these particles and the only unknown variable is the displacement field :u. In the porous media, denoted the matrix, we have both the displacement field, :u, as well as the liquid pressure, :p, as unknown. The computational domain is shown below (the outdated figure doesn't show correct boundary conditions)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"<table><tbody><tr height=\"300px\"><td style=\"text-align: left;\">","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Computational domain)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Pressure evolution)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: Pressure legend)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: u2 evolution)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"(Image: u2 legend)","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</tr><tr><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Computational domain","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Pressure evolution","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td></td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Vertical displacements¨","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td><td>","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"</td></tr></tbody></table>","category":"page"},{"location":"examples/porous_media/#Theory-of-porous-media","page":"Porous media","title":"Theory of porous media","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"The strong forms are given as","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nboldsymbolsigma(boldsymbolepsilon p) cdot boldsymbolnabla = boldsymbol0 \ndotPhi(boldsymbolepsilon p) + boldsymbolw(p) cdot boldsymbolnabla = 0\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"where boldsymbolepsilon = leftboldsymboluotimesboldsymbolnablaright^mathrmsym The constitutive relationships are","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nboldsymbolsigma = boldsymbolmathsfEboldsymbolepsilon - alpha p boldsymbolI \nboldsymbolw = - k boldsymbolnabla p \nPhi = phi + alpha mathrmtr(boldsymbolepsilon) + beta p\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"with boldsymbolmathsfE=2G boldsymbolmathsfI^mathrmdev + 3K boldsymbolIotimesboldsymbolI. The material parameters are then the shear modulus, G, bulk modulus, K, permeability, k, Biot's coefficient, alpha, and liquid compressibility, beta. The porosity, phi, doesn't enter into the equations (A different porosity leads to different skeleton stiffness and permeability).","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"The variational (weak) form can then be derived for the variations boldsymboldelta u and delta p as","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nint_Omega leftleftboldsymboldelta uotimesboldsymbolnablaright^mathrmsym\nboldsymbolmathsfEboldsymbolepsilon - boldsymboldelta u cdot boldsymbolnabla alpha pright mathrmdOmega\n= int_Gamma boldsymboldelta u cdot boldsymbolt mathrmd Gamma \nint_Omega leftdelta p leftalpha dotboldsymbolu cdot boldsymbolnabla + beta dotpright +\nboldsymbolnabla(delta p) cdot k boldsymbolnablaright mathrmdOmega\n= int_Gamma delta p w_mathrmn mathrmd Gamma\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"where boldsymbolt=boldsymbolncdotboldsymbolsigma is the traction and w_mathrmn = boldsymbolncdotboldsymbolw is the normal flux.","category":"page"},{"location":"examples/porous_media/#Finite-element-form","page":"Porous media","title":"Finite element form","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Discretizing in space using finite elements, we obtain the vector equation r_i = f_i^mathrmint - f_i^mathrmext where f^mathrmext are the external \"forces\", and f_i^mathrmint are the internal \"forces\". We split this into the displacement part r_i^mathrmu = f_i^mathrmintu - f_i^mathrmextu and pressure part r_i^mathrmp = f_i^mathrmintp - f_i^mathrmextp to obtain the discretized equation system","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"beginaligned\nf_i^mathrmintu = int_Omega boldsymboldelta N^mathrmu_iotimesboldsymbolnabla^mathrmsym  boldsymbolmathsfE  boldsymboluotimesboldsymbolnabla^mathrmsym \n- boldsymboldelta N^mathrmu_i cdot boldsymbolnabla alpha p mathrmdOmega\n= int_Gamma boldsymboldelta N^mathrmu_i cdot boldsymbolt mathrmd Gamma \nf_i^mathrmintp = int_Omega delta N_i^mathrmp alpha dotboldsymbolucdotboldsymbolnabla  + betadotp + boldsymbolnabla(delta N_i^mathrmp) cdot k boldsymbolnabla(p) mathrmdOmega\n= int_Gamma delta N_i^mathrmp w_mathrmn mathrmd Gamma\nendaligned","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Approximating the time-derivatives, dotboldsymboluapprox leftboldsymbolu-^nboldsymbolurightDelta t and dotpapprox leftp-^nprightDelta t, we can implement the finite element equations in the residual form r_i(boldsymbola(t) t) = 0 where the vector boldsymbola contains all unknown displacements u_i and pressures p_i. We use automatic differentiation to get the jacobian.","category":"page"},{"location":"examples/porous_media/#Implementation","page":"Porous media","title":"Implementation","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"We now solve the problem step by step. The full program with fewer comments is found in the final section","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Required packages","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"using Ferrite, FerriteMeshParser, Tensors\nusing FerriteAssembly, FerriteProblems, FerriteNeumann, FESolvers\nusing MaterialModelsBase\nimport FerriteProblems as FP\nimport MaterialModelsBase as MMB","category":"page"},{"location":"examples/porous_media/#Physics","page":"Porous media","title":"Physics","text":"","category":"section"},{"location":"examples/porous_media/#Elastic-material","page":"Porous media","title":"Elastic material","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"For the elastic material, we just define the material following the MaterialModelsBase.jl interface:","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct Elastic{T} <: AbstractMaterial\n    G::T\n    K::T\n    E4::SymmetricTensor{4,2,T,9}\nend\nfunction Elastic(;E=2.e3, ν=0.3)\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n    I2 = one(SymmetricTensor{2,2})\n    I4vol = I2⊗I2\n    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3\n    E4 = 2G*I4dev + K*I4vol\n    return Elastic(G, K, E4)\nend;\n\nfunction MMB.material_response(m::Elastic, ϵ, args...; kwargs...)\n    σ = m.E4 ⊡ ϵ\n    return σ, m.E4, NoMaterialState()\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Poroelastic-material","page":"Porous media","title":"Poroelastic material","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"For the poroelastic material, we reuse the elastic part from above, but add additionally required properties","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct PoroElastic{E<:Elastic,T}\n    elastic::E\n    k::T    # [mm^4/Ns] Permeability\n    α::T    # [-] Biot's coefficient\n    β::T    # [1/MPa] Liquid bulk modulus\nend\nfunction PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)\n    return PoroElastic(elastic, k, α, β)\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"And then we also have to define the specific element routine which we do by defining the residual and using autodiff to calculate the tangent","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, dh_fh, Δt, buffer)\n    # Setup cellvalues and give easier names\n    cv_u = cv[:u]\n    cv_p = cv[:p]\n    num_u = getnbasefunctions(cv_u)\n    num_p = getnbasefunctions(cv_p)\n\n    # Assign views to the matrix and vector parts\n    ae_old = FerriteAssembly.get_aeold(buffer)\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    ru = @view re[udofs]\n    rp = @view re[pdofs]\n    ue = @view ae[udofs]\n    pe = @view ae[pdofs]\n    ue_old = @view ae_old[udofs]\n    pe_old = @view ae_old[pdofs]\n\n    # Assemble stiffness and force vectors\n    for q_point in 1:getnquadpoints(cv_u)\n        # Calculate variables in the current quadrature point\n        dΩ = getdetJdV(cv_u, q_point)\n        ϵ = function_symmetric_gradient(cv_u, q_point, ue)\n        ϵ_old = function_symmetric_gradient(cv_u, q_point, ue_old)\n        p = function_value(cv_p, q_point, pe)\n        p_old = function_value(cv_p, q_point, pe_old)\n        ∇p = function_gradient(cv_p, q_point, pe)\n        pdot = (p-p_old)/Δt\n        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt\n        σeff = material.elastic.E4 ⊡ ϵ\n\n        # Assemble residual contributions\n        for iᵤ in 1:num_u\n            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)\n            div_δNu = shape_divergence(cv_u, q_point, iᵤ)\n            ru[iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ\n        end\n        for iₚ in 1:num_p\n            δNp = shape_value(cv_p, q_point, iₚ)\n            ∇δNp = shape_gradient(cv_p, q_point, iₚ)\n            rp[iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Problem-definition","page":"Porous media","title":"Problem definition","text":"","category":"section"},{"location":"examples/porous_media/#Mesh-import","page":"Porous media","title":"Mesh import","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"In this example, we import the mesh from the Abaqus input file, porous_media_0p75.inp using FerriteMeshParser's get_ferrite_grid function. (A finer mesh, porous_media_0p25.inp, is also available) We then create one cellset for each phase (solid and porous) for each element type. These 4 sets will later be used in their own FieldHandler","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function get_grid()\n    # Import grid from abaqus mesh\n    grid = get_ferrite_grid(joinpath(@__DIR__, \"porous_media\", \"porous_media_0p75.inp\"))\n\n    # Create cellsets for each fieldhandler\n    addcellset!(grid, \"solid3\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"solid4\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS4R\")))\n    addcellset!(grid, \"porous3\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"porous4\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS4R\")))\n\n    # Create faceset for the sides and top\n    addfaceset!(grid, \"sides\", x->(first(x) < eps() || first(x) ≈ 5.0))\n    addfaceset!(grid, \"top\", x->(last(x) ≈ 10.0))\n    return grid\nend","category":"page"},{"location":"examples/porous_media/#Problem-setup","page":"Porous media","title":"Problem setup","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Define the finite element interpolation, integration, and boundary conditions.","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"function create_definition(;t_rise=0.1, p_max=100.0)\n\n    grid = get_grid()\n\n    # Setup the interpolation and integration rules\n    dim=Ferrite.getdim(grid)\n    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()\n    ip4_lin = Lagrange{dim, RefCube, 1}()\n    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()\n    ip4_quad = Lagrange{dim, RefCube, 2}()\n    qr3 = QuadratureRule{dim, RefTetrahedron}(1)\n    qr4 = QuadratureRule{dim, RefCube}(2)\n\n    # Setup the MixedDofHandler\n    dh = MixedDofHandler(grid)\n    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,\"solid3\")))\n    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,\"solid4\")))\n    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,\"porous3\")))\n    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,\"porous4\")))\n    close!(dh)\n\n    # Setup cellvalues with the same order as the FieldHandlers in the dh\n    # - Linear displacement elements in the solid domain\n    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain\n    cv = ( CellVectorValues(qr3, ip3_lin),\n           CellVectorValues(qr4, ip4_lin),\n           (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin)),\n           (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin)) )\n\n    # Add boundary conditions\n    # Use `Ferrite.jl` PR427 (temporarily included in FerriteProblems.jl)\n    # to make Dirichlet conditions easier and more general\n    ch = ConstraintHandler(dh);\n    # Fix bottom in y and sides in x\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"bottom\"), (x, t) -> zero(Vec{1}), [2]))\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"sides\"), (x,t) -> zero(Vec{1}), [1]))\n    # Zero pressure on top surface\n    add!(ch, Dirichlet(:p, getfaceset(grid, \"top\"), (x,t) -> 0.0))\n    close!(ch)\n\n    # Add Neumann boundary conditions - normal traction on top\n    nh = NeumannHandler(dh);\n    add!(nh, Neumann(:u, 2, getfaceset(grid, \"top\"), (x,t,n) -> -n*clamp(t/t_rise,0,1)*p_max))\n\n    # We then need one material per fieldhandler:\n    materials = (Elastic(), Elastic(), PoroElastic(), PoroElastic())\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=materials, cc=FP.RelativeResidualElementScaling())\nend;\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Postprocessing","page":"Porous media","title":"Postprocessing","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"struct PostProcess{PVD}\n    pvd::PVD\n    filestem::String\nend\nfunction PostProcess(filestem=\"porous_media\")\n    pvd = paraview_collection(\"$filestem.pvd\")\n    return PostProcess(pvd, filestem)\nend\n\nfunction FESolvers.postprocess!(post::PostProcess, p, step, solver)\n    vtk_grid(\"$(post.filestem)-$step\", FP.getdh(p)) do vtk\n        vtk_point_data(vtk, FP.getdh(p), FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend\n\nFP.close_postprocessing(post::PostProcess, args...) = vtk_save(post.pvd);\nnothing #hide","category":"page"},{"location":"examples/porous_media/#Solving","page":"Porous media","title":"Solving","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"We solve the problem by using linearly increasing time steps","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"problem = FerriteProblem(create_definition(), PostProcess())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x->x^2, range(0, 1, 41))))\nsolve_problem!(problem, solver)","category":"page"},{"location":"examples/porous_media/#porous-media-plain-program","page":"Porous media","title":"Plain program","text":"","category":"section"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"Here follows a version of the program without any comments. The file is also available here: porous_media.jl.","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"using Ferrite, FerriteMeshParser, Tensors\nusing FerriteAssembly, FerriteProblems, FerriteNeumann, FESolvers\nusing MaterialModelsBase\nimport FerriteProblems as FP\nimport MaterialModelsBase as MMB\n\nstruct Elastic{T} <: AbstractMaterial\n    G::T\n    K::T\n    E4::SymmetricTensor{4,2,T,9}\nend\nfunction Elastic(;E=2.e3, ν=0.3)\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n    I2 = one(SymmetricTensor{2,2})\n    I4vol = I2⊗I2\n    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3\n    E4 = 2G*I4dev + K*I4vol\n    return Elastic(G, K, E4)\nend;\n\nfunction MMB.material_response(m::Elastic, ϵ, args...; kwargs...)\n    σ = m.E4 ⊡ ϵ\n    return σ, m.E4, NoMaterialState()\nend;\n\nstruct PoroElastic{E<:Elastic,T}\n    elastic::E\n    k::T    # [mm^4/Ns] Permeability\n    α::T    # [-] Biot's coefficient\n    β::T    # [1/MPa] Liquid bulk modulus\nend\nfunction PoroElastic(;elastic=Elastic(), k=0.05, α=1.0, β=1/2e3)\n    return PoroElastic(elastic, k, α, β)\nend;\n\nfunction FerriteAssembly.element_residual!(re, state, ae, material::PoroElastic, cv::NamedTuple, dh_fh, Δt, buffer)\n    # Setup cellvalues and give easier names\n    cv_u = cv[:u]\n    cv_p = cv[:p]\n    num_u = getnbasefunctions(cv_u)\n    num_p = getnbasefunctions(cv_p)\n\n    # Assign views to the matrix and vector parts\n    ae_old = FerriteAssembly.get_aeold(buffer)\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    ru = @view re[udofs]\n    rp = @view re[pdofs]\n    ue = @view ae[udofs]\n    pe = @view ae[pdofs]\n    ue_old = @view ae_old[udofs]\n    pe_old = @view ae_old[pdofs]\n\n    # Assemble stiffness and force vectors\n    for q_point in 1:getnquadpoints(cv_u)\n        # Calculate variables in the current quadrature point\n        dΩ = getdetJdV(cv_u, q_point)\n        ϵ = function_symmetric_gradient(cv_u, q_point, ue)\n        ϵ_old = function_symmetric_gradient(cv_u, q_point, ue_old)\n        p = function_value(cv_p, q_point, pe)\n        p_old = function_value(cv_p, q_point, pe_old)\n        ∇p = function_gradient(cv_p, q_point, pe)\n        pdot = (p-p_old)/Δt\n        div_udot = (tr(ϵ)-tr(ϵ_old))/Δt\n        σeff = material.elastic.E4 ⊡ ϵ\n\n        # Assemble residual contributions\n        for iᵤ in 1:num_u\n            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)\n            div_δNu = shape_divergence(cv_u, q_point, iᵤ)\n            ru[iᵤ] += (∇δNu ⊡ σeff - div_δNu*material.α*p)*dΩ\n        end\n        for iₚ in 1:num_p\n            δNp = shape_value(cv_p, q_point, iₚ)\n            ∇δNp = shape_gradient(cv_p, q_point, iₚ)\n            rp[iₚ] += (δNp*(material.α*div_udot + material.β*pdot) + (∇δNp ⋅ ∇p)*material.k) * dΩ\n        end\n    end\nend;\n\nfunction get_grid()\n    # Import grid from abaqus mesh\n    grid = get_ferrite_grid(joinpath(@__DIR__, \"porous_media\", \"porous_media_0p75.inp\"))\n\n    # Create cellsets for each fieldhandler\n    addcellset!(grid, \"solid3\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"solid4\", intersect(getcellset(grid, \"solid\"), getcellset(grid, \"CPS4R\")))\n    addcellset!(grid, \"porous3\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS3\")))\n    addcellset!(grid, \"porous4\", intersect(getcellset(grid, \"porous\"), getcellset(grid, \"CPS4R\")))\n\n    # Create faceset for the sides and top\n    addfaceset!(grid, \"sides\", x->(first(x) < eps() || first(x) ≈ 5.0))\n    addfaceset!(grid, \"top\", x->(last(x) ≈ 10.0))\n    return grid\nend\n\nfunction create_definition(;t_rise=0.1, p_max=100.0)\n\n    grid = get_grid()\n\n    # Setup the interpolation and integration rules\n    dim=Ferrite.getdim(grid)\n    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()\n    ip4_lin = Lagrange{dim, RefCube, 1}()\n    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()\n    ip4_quad = Lagrange{dim, RefCube, 2}()\n    qr3 = QuadratureRule{dim, RefTetrahedron}(1)\n    qr4 = QuadratureRule{dim, RefCube}(2)\n\n    # Setup the MixedDofHandler\n    dh = MixedDofHandler(grid)\n    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,\"solid3\")))\n    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,\"solid4\")))\n    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,\"porous3\")))\n    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,\"porous4\")))\n    close!(dh)\n\n    # Setup cellvalues with the same order as the FieldHandlers in the dh\n    # - Linear displacement elements in the solid domain\n    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain\n    cv = ( CellVectorValues(qr3, ip3_lin),\n           CellVectorValues(qr4, ip4_lin),\n           (u=CellVectorValues(qr3, ip3_quad, ip3_lin), p=CellScalarValues(qr3, ip3_lin)),\n           (u=CellVectorValues(qr4, ip4_quad, ip4_lin), p=CellScalarValues(qr4, ip4_lin)) )\n\n    # Add boundary conditions\n    # Use `Ferrite.jl` PR427 (temporarily included in FerriteProblems.jl)\n    # to make Dirichlet conditions easier and more general\n    ch = ConstraintHandler(dh);\n    # Fix bottom in y and sides in x\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"bottom\"), (x, t) -> zero(Vec{1}), [2]))\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"sides\"), (x,t) -> zero(Vec{1}), [1]))\n    # Zero pressure on top surface\n    add!(ch, Dirichlet(:p, getfaceset(grid, \"top\"), (x,t) -> 0.0))\n    close!(ch)\n\n    # Add Neumann boundary conditions - normal traction on top\n    nh = NeumannHandler(dh);\n    add!(nh, Neumann(:u, 2, getfaceset(grid, \"top\"), (x,t,n) -> -n*clamp(t/t_rise,0,1)*p_max))\n\n    # We then need one material per fieldhandler:\n    materials = (Elastic(), Elastic(), PoroElastic(), PoroElastic())\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=materials, cc=FP.RelativeResidualElementScaling())\nend;\n\nstruct PostProcess{PVD}\n    pvd::PVD\n    filestem::String\nend\nfunction PostProcess(filestem=\"porous_media\")\n    pvd = paraview_collection(\"$filestem.pvd\")\n    return PostProcess(pvd, filestem)\nend\n\nfunction FESolvers.postprocess!(post::PostProcess, p, step, solver)\n    vtk_grid(\"$(post.filestem)-$step\", FP.getdh(p)) do vtk\n        vtk_point_data(vtk, FP.getdh(p), FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend\n\nFP.close_postprocessing(post::PostProcess, args...) = vtk_save(post.pvd);\n\nproblem = FerriteProblem(create_definition(), PostProcess())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(map(x->x^2, range(0, 1, 41))))\nsolve_problem!(problem, solver)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"","category":"page"},{"location":"examples/porous_media/","page":"Porous media","title":"Porous media","text":"This page was generated using Literate.jl.","category":"page"}]
}
