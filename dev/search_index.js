var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann\n\nusing Plots; gr()","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This file defines the","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"J2Plasticity material type with the constructor J2Plasticity(E,ν,σy0,H)\nState variable struct with constructor J2PlasticityMaterialState()\ncompute_stress_tangent(ϵ, material, old_state) -> σ, D, state function","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"traction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = create_states(dh, x->J2PlasticityMaterialState(), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, we need to define the element routine, following FerriteAssemblys interface. This function is almost equivalent to the assemble_cell! in the original example, except that","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We don't have to reinit! as FerriteAssembly does that before calling\nThe traction is handled by FerriteNeumann and is not done for each cell","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::AbstractVector,\n    ue::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    args...)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"At this point, we can define problem = FerriteProblem(setup_problem_definition()), which can be solved with FESolvers.jl's solve_problem!. But to get any results apart from the final state, we need to define the postprocessing after each step.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. For convenience, FerriteProblems will call FESolvers.postprocess! with the post as the first argument making it easy to dispatch on:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FerriteProblems.gettime(p)))\n    push!(post.umag, maximum(abs, FESolvers.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FerriteProblems.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FerriteProblems.savedofdata!(p.io, FESolvers.getunknowns(p))\n    # * Save the state in each integration point\n    FerriteProblems.saveipdata!(p.io, FerriteProblems.getstate(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We also define a helper function to plot the results after completion","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results. Here, we use FerriteProblem's safesolve that (1) creates our full problem::FerriteProblem and (2) ensures that files are closed even when the problem doesn't converge.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"global umax_solution = [0.0] # To save result for test #hide\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n    umax_solution[1] = problem.post.umag[end] # Save value for comparison  #hide\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\nusing Test # Compare to Ferrite.jl's example #hide\n@test isapprox(umax_solution[1], 0.254452; rtol=1.e-4);  #hide\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann\n\nusing Plots; gr()\n\ninclude(\"J2Plasticity.jl\");\n\ntraction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = create_states(dh, x->J2PlasticityMaterialState(), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::AbstractVector,\n    ue::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    args...)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FerriteProblems.gettime(p)))\n    push!(post.umag, maximum(abs, FESolvers.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FerriteProblems.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FerriteProblems.savedofdata!(p.io, FESolvers.getunknowns(p))\n    # * Save the state in each integration point\n    FerriteProblems.saveipdata!(p.io, FerriteProblems.getstate(p), \"state\")\nend;\n\nfunction plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the  FESolvers.jl package with  Ferrite.jl, as well as the supporting packages  FerriteAssembly.jl and  FerriteNeumann.jl.  There is also extensive support for organizing your simulations  by saving both setup and results as .jld2 using JLD2.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The workflow requires you to create its FerriteProblem type which  can then be solved by FESolvers.jl.  The easiest way to get started is to just follow the examples.  Note that the documentation of Ferrite.jl, FerriteAssembly.jl,  and FerriteNeumann.jl should be considered as well. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct FerriteProblem{POST,DEF,BUF,IOT}\n    def::DEF\n    post::POST\n    buf::BUF\n    io::IOT\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"with FerriteProblem(def, post=nothing, io=nothing) as constructor.  The four parts have distinct tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"def::FEDefinition is responsible for the full problem definition.  I.e., given def, the full simulation should be possible to replicate,  given the same solver from FESolvers.jl\npost contains all information related to the postprocessing of each step.  This typically varies a lot between simulations,  and is the first type parameter to allow easy  dispatch on problems with different posts.  \nbuf::FEBuffer contains all buffer values,  these are not necessary (nor desirable) to save,  and can be recreated each time the constructor is called.\nio::FerriteIO: This field enable file handling to allow easy saving  and retrieving of results from a simulation using JLD2 files.","category":"page"}]
}
