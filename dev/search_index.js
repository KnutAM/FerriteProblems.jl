var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann\n\nusing Plots; gr()","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This file defines the","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"J2Plasticity material type with the constructor J2Plasticity(E,ν,σy0,H)\nState variable struct with constructor J2PlasticityMaterialState()\ncompute_stress_tangent(ϵ, material, old_state) -> σ, D, state function","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"traction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = create_states(dh, x->J2PlasticityMaterialState(), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, we need to define the element routine, following FerriteAssemblys interface. This function is almost equivalent to the assemble_cell! in the original example, except that","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We don't have to reinit! as FerriteAssembly does that before calling\nThe traction is handled by FerriteNeumann and is not done for each cell","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::AbstractVector,\n    ue::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    args...)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"At this point, we can define problem = FerriteProblem(setup_problem_definition()), which can be solved with FESolvers.jl's solve_problem!. But to get any results apart from the final state, we need to define the postprocessing after each step.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. Note that FerriteProblems exports const FP=FerriteProblems to avoid polluting the namespace with many exported functions. It is also possible to access the FESolvers functions getunknowns, getresidual, and getjacobian via FP For convenience, FerriteProblems will call FESolvers.postprocess! with the post as the first argument making it easy to dispatch on:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p)))\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We also define a helper function to plot the results after completion","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results. Here, we use FerriteProblems' safesolve that (1) creates our full problem::FerriteProblem and (2) ensures that files are closed even when the problem doesn't converge.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"global umax_solution = [0.0] # To save result for test #hide\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n    umax_solution[1] = problem.post.umag[end] # Save value for comparison  #hide\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\nusing Test # Compare to Ferrite.jl's example #hide\n@test isapprox(umax_solution[1], 0.254452; rtol=1.e-4);  #hide\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteAssembly, FerriteNeumann\n\nusing Plots; gr()\n\ninclude(\"J2Plasticity.jl\");\n\ntraction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states\n    states = create_states(dh, x->J2PlasticityMaterialState(), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::AbstractVector,\n    ue::AbstractVector, material::J2Plasticity, cellvalues::CellVectorValues,\n    args...)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ue) # Total strain\n        σ, D, state[q_point] = compute_stress_tangent(ϵ, material, state[q_point])\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ # add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p)))\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\n\nfunction plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = safesolve(solver, def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-types-and-running-simulations","page":"API","title":"Main types and running simulations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblem\nFEDefinition\nFerriteIO\nsafesolve\nFP.close_problem","category":"page"},{"location":"api/#FerriteProblems.FerriteProblem","page":"API","title":"FerriteProblems.FerriteProblem","text":"FerriteProblem(def::FEDefinition, post=nothing, io=nothing)\n\nConstructor that makes the minimum required to run simulation.  Optional postprocessing and io::FerriteIO if desired. \n\n\n\n\n\nFerriteProblem(def::FEDefinition, post, savefolder::String)\n\nConstructor with automatic generation of FerriteIO by just specifying  in which folder data should be saved. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FEDefinition","page":"API","title":"FerriteProblems.FEDefinition","text":"FEDefinition(dh, ch, nh, cv, m, bl, initialstate, ic)\nFEDefinition(;dh, ch, cv, m,\n    nh=NeumannHandler(dh), bl=nothing,\n    initialstate=create_empty_states(dh,m),\n    ic=(),\n    )\n\nThe definition of the FE-problem, this data describes the finite  element problem as a function of time. For how long to run and how  to step through time is typically done by FESolvers.jl. \n\nFields/inputs\n\nSee more information below for items marked with *\n\ndh: The dof handler, Union{DofHandler,MixedDofHandler} (Ferrite.jl)\nch: The constraint handler, ConstraintHandler (Ferrite.jl)\nnh: The neumann bc handler, NeumannHandler (FerriteNeumann.jl)\ncv: The cellvalues, e.g. CellValues (*)\nm: The material definition, user defined type - passed into element. (*)\nbl: Source term/body load, user defined type - available from the element routine (*)\ninitialstate: The initial state variables for each cell in the grid,  can created by FerriteAssembly.create_states (*)\nic: Initial conditions. NamedTuple with a function f(x) for each field that  has a nonzero initial condition. Used by the initial_conditions! function.\n\nMixedDofHandler\n\nWhen the MixedDofHandler is used, we have an outer loop over each of its FieldHandlers. Therefore, cv, m, and bl may be provided for each of these fields by providing them as  a tuple. Otherwise, they are duplicated for each field (by reference)\n\ninitialstate must be a tuple containing Dict{Int} with states for the cells in the relevant  FieldHandler's cellset. \n\nMultiple CellValues for each element In coupled problems, each element might require multiple CellValues.  If the same should be used for all fields (even if only one FieldHandler),  a NamedTuple is the easiest (the alternative is a Tuple of Tuples).  If different multiple CellValues should be used for each field, then pass as  Tuple of NamedTuple/Tuple\n\nMultiple materials\n\nNote: The following setup is not needed if you have one material for each FieldHandler when using a MixedDofHandler\n\nIf you want to have different materials on different parts of the grid,  you should first define those cellsets, and then define each material  as a value of m::Dict{String} with the name of the cellset as key. \n\nYou may do the same for bl and cv.  Otherwise, the same values will be used for every cellset. \n\nCombine with MixedDofHandler:  Follow the required input for MixedDofHandler,  but wrap items (at least the material and initialstate) in Dicts as described above\n\nState variables:  initialstate::Dict{String} must mirror the datastructure of m::Dict{String}: For each key in m::Dict{String}, initialstate[key] holds a collection of states  for the cells in getcellset(dh,key).\n\nIf MixedDofHandler, then initialstate[key]::NTuple{N,<:Dict{Int}},  and if DofHandler, then initialstate[key]::Dict{Int}\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FerriteIO","page":"API","title":"FerriteProblems.FerriteIO","text":"FerriteIO(\n    folder::String, def::FEDefinition, post=nothing; \n    def_file=\"FEDefinition.jld2\", \n    postfile=\"FEPost.jld2\",\n    T=Float64, \n    nsteps_per_file=typemax(Int), \n    switchsize=Inf\n    )\n\nConstructor for creating a FerriteIO when simulating. \n\n\n\n\n\nFerriteIO(filename::String)\n\nConstructor for reading a FerriteIO that was saved during a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.safesolve","page":"API","title":"FerriteProblems.safesolve","text":"safesolve(solver, def::FEDefinition, args...; kwargs...)\n\nStarts by creating FerriteProblem from def and args/kwargs  and then wraps the call to FESolvers.solve_problem! in  try ... finally to ensure that close_problem is  called even in the case of no convergence.  \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.close_problem","page":"API","title":"FerriteProblems.close_problem","text":"close_problem(p::FerriteProblem)\n\nMethod for closing all open files before ending the simulation\n\n\n\n\n\n","category":"function"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FP.getdh\nFP.getch\nFP.getnh\nFP.getcv\nFP.getmaterial\nFP.getbodyload\nFP.getjacobian\nFP.getunknowns\nFP.getresidual\nFP.getneumannforce\nFP.getoldunknowns\nFP.getstate\nFP.getoldstate\nFP.gettime\nFP.getoldtime","category":"page"},{"location":"api/#FerriteProblems.getdh","page":"API","title":"FerriteProblems.getdh","text":"FP.getdh(p::FerriteProblem)\n\nGet dh::Ferrite.AbstractDofHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getch","page":"API","title":"FerriteProblems.getch","text":"FP.getch(p::FerriteProblem)\n\nGet the ConstraintHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnh","page":"API","title":"FerriteProblems.getnh","text":"FP.getnh(p::FerriteProblem)\n\nGet the NeumannHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcv","page":"API","title":"FerriteProblems.getcv","text":"FP.getcv(p::FerriteProblem)\n\nGet the cell values from the FEDefinition.  Note that this could also be a Tuple or NamedTuple depending on  what was initially given to FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getmaterial","page":"API","title":"FerriteProblems.getmaterial","text":"FP.getmaterial(p::FerriteProblem)\n\nGet the material from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getbodyload","page":"API","title":"FerriteProblems.getbodyload","text":"FP.getbodyload(p::FerriteProblem)\n\nGet the bodyload given to the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getjacobian","page":"API","title":"FESolvers.getjacobian","text":"FP.getjacobian(p::FerriteProblem)\n\nGet the current jacobian matrix from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getjacobian\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getunknowns","page":"API","title":"FESolvers.getunknowns","text":"FP.getunknowns(p::FerriteProblem)\n\nGet the current vector of unknowns from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getunknowns\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getresidual","page":"API","title":"FESolvers.getresidual","text":"FP.getresidual(p::FerriteProblem)\n\nGet the current residual vector from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getresidual\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getneumannforce","page":"API","title":"FerriteProblems.getneumannforce","text":"FP.getneumannforce(p::FerriteProblem)\n\nGet the current external force vector caused by  Neumann boundary conditions. Note that this vector  does not include external forces added during the  cell assembly; only forces added with the NeumannHandler\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldunknowns","page":"API","title":"FerriteProblems.getoldunknowns","text":"FP.getoldunknowns(p::FerriteProblem)\n\nGet the vector of unknowns from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getstate","page":"API","title":"FerriteProblems.getstate","text":"FP.getstate(p::FerriteProblem)\n\nGet the current state variables\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldstate","page":"API","title":"FerriteProblems.getoldstate","text":"FP.getoldstate(p::FerriteProblem)\n\nGet the state variables from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettime","page":"API","title":"FerriteProblems.gettime","text":"FP.gettime(p::FerriteProblem)\n\nGet the current time\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldtime","page":"API","title":"FerriteProblems.getoldtime","text":"FP.getoldtime(p::FerriteProblem)\n\nGet time of the previous converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#Special-cases","page":"API","title":"Special cases","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FP.allocate_material_cache","category":"page"},{"location":"api/#FerriteProblems.allocate_material_cache","page":"API","title":"FerriteProblems.allocate_material_cache","text":"FP.allocate_material_cache(material)\n\nIn case the material requires a cache to be available during the element routine, this function can be overloaded for the specific material to define such a cache to be included in the FerriteAssembly.CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#Saving-and-loading-data","page":"API","title":"Saving and loading data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FESolvers.postprocess!\nFP.addstep!\nFP.gettimedata\nFP.savedofdata!\nFP.getdofdata\nFP.savenodedata!\nFP.getnodedata\nFP.savecelldata!\nFP.getcelldata\nFP.saveipdata!\nFP.getipdata\nFP.saveglobaldata!\nFP.getglobaldata\nFP.getdef\nFP.getpost","category":"page"},{"location":"api/#FESolvers.postprocess!","page":"API","title":"FESolvers.postprocess!","text":"FESolvers.postprocess!(p::FerriteProblem, step, solver)\n\nWhen FESolvers call this function for p::FerriteProblem,  the following function\n\nFESolvers.postprocess!(post, p::FerriteProblem, step, solver)\n\nis called where post=p.post (unless you define a different override).  This allows you to easily define the dispatch on your postprocessing  type as FESolvers.postprocess!(post::MyPostType, p, step, solver)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.addstep!","page":"API","title":"FerriteProblems.addstep!","text":"FP.addstep!(io::FerriteIO, p::FerriteProblem)\n\nAdd a new step to be saved by io at the time gettime(p) Must be called before adding any new data\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettimedata","page":"API","title":"FerriteProblems.gettimedata","text":"gettimedata(io::FerriteIO)\ngettimedata(io::FerriteIO, step)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savedofdata!","page":"API","title":"FerriteProblems.savedofdata!","text":"FP.savedofdata!(io::FerriteIO, vals, dt_order=0, field=\"dof\")\n\nSave data pertaining to each degree of freedom. Use a different field than \"dof\"` to save data located at each dof,  but not the actual dof values (e.g. the residual vector)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdofdata","page":"API","title":"FerriteProblems.getdofdata","text":"FP.getdofdata(io::FerriteIO, step, field=\"dof\"; dt_order=0)\n\nGet the data saved by savedofdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savenodedata!","page":"API","title":"FerriteProblems.savenodedata!","text":"FP.savenodedata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data located at each node. By convention this should be indexed by the node numbers in the grid. (E.g. a Vector for all nodes or a Dict{Int} with keys the node numbers)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnodedata","page":"API","title":"FerriteProblems.getnodedata","text":"FP.getnodedata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by savenodedata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savecelldata!","page":"API","title":"FerriteProblems.savecelldata!","text":"FP.savecelldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each cell.  By convention this should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcelldata","page":"API","title":"FerriteProblems.getcelldata","text":"FP.getcelldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by savecelldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveipdata!","page":"API","title":"FerriteProblems.saveipdata!","text":"FP.saveipdata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each integration point in cells in the grid.  By convention the data for each cell should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices) Note that it is on the user to know how the integration points are numbered,  i.e. which QuadratureRule that was used. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getipdata","page":"API","title":"FerriteProblems.getipdata","text":"FP.getipdata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by saveipdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveglobaldata!","page":"API","title":"FerriteProblems.saveglobaldata!","text":"FP.saveglobaldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data that is global to the entire simulation, i.e. global quantites such as  reaction forces, total dissipation, etc. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getglobaldata","page":"API","title":"FerriteProblems.getglobaldata","text":"FP.getglobaldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by saveglobaldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdef","page":"API","title":"FerriteProblems.getdef","text":"FP.getdef(io::FerriteIO)\n\nLoad the FEDefinition from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getpost","page":"API","title":"FerriteProblems.getpost","text":"FP.getpost(io::FerriteIO)\n\nLoad the user defined post from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the  FESolvers.jl package with  Ferrite.jl, as well as the supporting packages  FerriteAssembly.jl and  FerriteNeumann.jl.  There is also extensive support for organizing your simulations  by saving both setup and results as .jld2 using JLD2.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The workflow requires you to create its FerriteProblem type which  can then be solved by FESolvers.jl.  The easiest way to get started is to just follow the examples.  Note that the documentation of Ferrite.jl, FerriteAssembly.jl,  and FerriteNeumann.jl should be considered as well. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct FerriteProblem{POST,DEF,BUF,IOT}\n    def::DEF\n    post::POST\n    buf::BUF\n    io::IOT\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"with FerriteProblem(def, post=nothing, io=nothing) as constructor.  The four parts have distinct tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"def::FEDefinition is responsible for the full problem definition.  I.e., given def, the full simulation should be possible to replicate,  given the same solver from FESolvers.jl\npost contains all information related to the postprocessing of each step.  This typically varies a lot between simulations,  and is the first type parameter to allow easy  dispatch on problems with different posts.  \nbuf::FEBuffer contains all buffer values,  these are not necessary (nor desirable) to save,  and can be recreated each time the constructor is called.\nio::FerriteIO: This field enable file handling to allow easy saving  and retrieving of results from a simulation using JLD2 files.","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note: These functions are not considered \"documented\" and changes here are therefore not considered breaking.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FP.FEBuffer\nFP.getcellbuffer\nFP.update_unknowns!\nFP.copy_states!\nFP.update_states!\nFP.reset_states!\nFP.settime!\nFP.update_time!\nFP.create_empty_states\nFP.filepath\nFP.datafilepath\nFP.new_file!\nFP.new_file_if_needed!\nFP.update_currentsize!\nFP.getfilenumber\nFP.open_if_needed!\nFP.checkkey\nFP.savedata!\nFP.getdata\nFP.get_dof2node\nFP.initial_conditions!","category":"page"},{"location":"internals/#FerriteProblems.FEBuffer","page":"Internals","title":"FerriteProblems.FEBuffer","text":"FEBuffer(K,x,r,f,xold,cellbuffer,state,old_state,time,old_time)\n\nA buffer to hold all values that are required to simulate,  but that are uniqely defined from the simulation definition\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteProblems.getcellbuffer","page":"Internals","title":"FerriteProblems.getcellbuffer","text":"FP.getcellbuffer(p::FerriteProblem)\n\nGet the cell buffers used during the assembly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_unknowns!","page":"Internals","title":"FerriteProblems.update_unknowns!","text":"FP.update_unknowns!(p::FerriteProblem)\n\nUpdate the vector of \"old\" unknowns to the values of the current vector of unknowns\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.copy_states!","page":"Internals","title":"FerriteProblems.copy_states!","text":"FP.copy_states!(to, from)\n\nPerform a \"deepcopy!\" of states in from into to.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_states!","page":"Internals","title":"FerriteProblems.update_states!","text":"FP.update_states!(p::FerriteProblem)\n\nUpdate the \"old\" state variables to the current values. Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.reset_states!","page":"Internals","title":"FerriteProblems.reset_states!","text":"FP.reset_states!(p::FerriteProblem)\n\nReset the current state variables to the old state values.  Called after each solution iteration unless the solution has converged. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.settime!","page":"Internals","title":"FerriteProblems.settime!","text":"FP.settime!(p::FerriteProblem, new_time)\n\nSet the current time to new_time Called when starting a new step (or when attempting the same  step number with a new time increment)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_time!","page":"Internals","title":"FerriteProblems.update_time!","text":"FP.update_time!(p::FerriteProblem)\n\nUpdate the old time to the current time.  Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.create_empty_states","page":"Internals","title":"FerriteProblems.create_empty_states","text":"FP.create_empty_states(dh, material)\n\nUsed to create empty states in case state variables aren't used in the simulation by calling FerriteAssembly.create_states without any input (returning nothing for each cell)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.filepath","page":"Internals","title":"FerriteProblems.filepath","text":"filepath(io::FerriteIO, args...) = joinpath(io.folder[], args...)\n\nGet the path of a file relative io's folder\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.datafilepath","page":"Internals","title":"FerriteProblems.datafilepath","text":"datafilepath(io::FerriteIO, num=length(io.datafiles))\n\nGet the path of the data file number num in io.datafiles\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file!","page":"Internals","title":"FerriteProblems.new_file!","text":"new_file!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file_if_needed!","page":"Internals","title":"FerriteProblems.new_file_if_needed!","text":"new_file_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_currentsize!","page":"Internals","title":"FerriteProblems.update_currentsize!","text":"update_currentsize!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getfilenumber","page":"Internals","title":"FerriteProblems.getfilenumber","text":"getfilenumber\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.open_if_needed!","page":"Internals","title":"FerriteProblems.open_if_needed!","text":"open_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.checkkey","page":"Internals","title":"FerriteProblems.checkkey","text":"checkkey\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.savedata!","page":"Internals","title":"FerriteProblems.savedata!","text":"savedata!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getdata","page":"Internals","title":"FerriteProblems.getdata","text":"getdata\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.get_dof2node","page":"Internals","title":"FerriteProblems.get_dof2node","text":"get_dof2node\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.initial_conditions!","page":"Internals","title":"FerriteProblems.initial_conditions!","text":"initial_conditions!(\n    a::AbstractVector, dh::DofHandler, field::Symbol, f::Function, \n    cellset=1:getncells(dh.grid),\n    ip_geo=_default_interpolation(dh)\n    )\n\nApply initial conditions using the function f\n\n\n\n\n\n","category":"function"}]
}
