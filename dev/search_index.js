var documenterSearchIndex = {"docs":
[{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/incompressible_elasticity.jl\"","category":"page"},{"location":"examples/incompressible_elasticity/#Incompressible-Elasticity","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This example is the adoption of Ferrite.jls example To adapt, we make a few changes, specifically that we don't use BlockArrays","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The full code, without comments, can be found in the next section.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteNeumann, FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\n\n# Problem setup","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"First we generate a simple grid, specifying the 4 corners of Cooks membrane.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Next we define a function to set up our cell- and facevalues.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We create a DofHandler, with two fields, :u and :p, with possibly different interpolations","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We also need to add Dirichlet boundary conditions on the \"clamped\" faceset. We specify a homogeneous Dirichlet bc on the displacement field, :u.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"The material is linear elastic, which is here specified by the shear and bulk moduli","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = create_bc(dh)\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=m)\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Physics-(element-routine)","page":"Incompressible Elasticity","title":"Physics (element routine)","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"We define the element according to FerriteAssembly, and without any Neumann contributions. We restrict this element to only work with FESolvers.LinearProblemSolver by not including the internal forces in residual. Since the problem results in a symmetric matrix we choose to only assemble the lower part, and then symmetrize it after the loop over the quadrature points.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, dh_fh, Δt, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    # Create views of the different fields\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    Ke_uu = @view Ke[udofs,udofs]\n    Ke_pu = @view Ke[pdofs,udofs]\n    Ke_pp = @view Ke[pdofs,pdofs]\n\n    # Temporary, should be cached\n    ∇Nu_sym_dev = zeros(SymmetricTensor{2,2,Float64,3}, n_basefuncs_u)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            for j in 1:i\n                Ke_uu[i,j] += 2 * mp.G * ∇Nu_sym_dev[i] ⊡ ∇Nu_sym_dev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δNp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδNu = shape_divergence(cellvalues_u, q_point, j)\n                Ke_pu[i,j] += -δNp * divδNu * dΩ\n            end\n            for j in 1:i\n                Np = shape_value(cellvalues_p, q_point, j)\n                Ke_pp[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Postprocessing","page":"Incompressible Elasticity","title":"Postprocessing","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"struct PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    dh = FP.getdh(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/incompressible_elasticity/#Solving-the-problem","page":"Incompressible Elasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"function build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(solver, p1)\nsolve_problem!(solver, p2)","category":"page"},{"location":"examples/incompressible_elasticity/#incompressible_elasticity-plain-program","page":"Incompressible Elasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"Here follows a version of the program without any comments. The file is also available here: incompressible_elasticity.jl.","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"using Ferrite\nusing FerriteNeumann, FerriteAssembly, FerriteProblems\nusing FESolvers\nimport FerriteProblems as FP\n\n# Problem setup\n\nfunction create_cook_grid(nx, ny)\n    corners = [Vec{2}((0.0,   0.0)),\n               Vec{2}((48.0, 44.0)),\n               Vec{2}((48.0, 60.0)),\n               Vec{2}((0.0,  44.0))]\n    grid = generate_grid(Triangle, (nx, ny), corners);\n    # facesets for boundary conditions\n    addfaceset!(grid, \"clamped\", x -> norm(x[1]) ≈ 0.0);\n    addfaceset!(grid, \"traction\", x -> norm(x[1]) ≈ 48.0);\n    return grid\nend;\n\nfunction create_values(interpolation_u, interpolation_p)\n    # quadrature rules\n    qr      = QuadratureRule{2,RefTetrahedron}(3)\n    face_qr = QuadratureRule{1,RefTetrahedron}(3)\n\n    # geometric interpolation\n    interpolation_geom = Lagrange{2,RefTetrahedron,1}()\n\n    # cell and facevalues for u\n    cellvalues_u = CellVectorValues(qr, interpolation_u, interpolation_geom)\n    facevalues_u = FaceVectorValues(face_qr, interpolation_u, interpolation_geom)\n\n    # cellvalues for p\n    cellvalues_p = CellScalarValues(qr, interpolation_p, interpolation_geom)\n\n    return cellvalues_u, cellvalues_p, facevalues_u\nend;\n\nfunction create_dofhandler(grid, ipu, ipp)\n    dh = DofHandler(grid)\n    push!(dh, :u, 2, ipu) # displacement\n    push!(dh, :p, 1, ipp) # pressure\n    close!(dh)\n    return dh\nend;\n\nfunction create_bc(dh)\n    dbc = ConstraintHandler(dh)\n    add!(dbc, Dirichlet(:u, getfaceset(dh.grid, \"clamped\"), (x,t) -> zero(Vec{2}), [1,2]))\n    close!(dbc)\n    t = 0.0\n    update!(dbc, t)\n    return dbc\nend;\n\nstruct LinearElasticity{T}\n    G::T\n    K::T\nend\nfunction LinearElasticity(;Emod, ν)\n    Gmod = Emod / 2(1 + ν)\n    Kmod = Emod * ν / ((1+ν) * (1-2ν))\n    return LinearElasticity(Gmod, Kmod)\nend\n\nfunction create_definition(ν, ip_u, ip_p)\n    grid = create_cook_grid(50, 50)\n    dh = create_dofhandler(grid, ip_u, ip_p)\n    ch = create_bc(dh)\n    cv_u, cv_p, fv = create_values(ip_u, ip_p)\n    cv = (u=cv_u, p=cv_p)   # Create NamedTuple\n\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"traction\"), (x,t,n)->Vec{2}((0.0, 1/16))))\n\n    m = LinearElasticity(;Emod=1.0, ν=ν)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=m)\nend;\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, mp::LinearElasticity, cv::NamedTuple, dh_fh, Δt, buffer\n    )\n    cellvalues_u = cv[:u]\n    cellvalues_p = cv[:p]\n    n_basefuncs_u = getnbasefunctions(cellvalues_u)\n    n_basefuncs_p = getnbasefunctions(cellvalues_p)\n    # Create views of the different fields\n    udofs = dof_range(dh_fh, :u)\n    pdofs = dof_range(dh_fh, :p)\n    Ke_uu = @view Ke[udofs,udofs]\n    Ke_pu = @view Ke[pdofs,udofs]\n    Ke_pp = @view Ke[pdofs,pdofs]\n\n    # Temporary, should be cached\n    ∇Nu_sym_dev = zeros(SymmetricTensor{2,2,Float64,3}, n_basefuncs_u)\n\n    # We only assemble lower half triangle of the stiffness matrix and then symmetrize it.\n    for q_point in 1:getnquadpoints(cellvalues_u)\n        for i in 1:n_basefuncs_u\n            ∇Nu_sym_dev[i] = dev(symmetric(shape_gradient(cellvalues_u, q_point, i)))\n        end\n        dΩ = getdetJdV(cellvalues_u, q_point)\n        for i in 1:n_basefuncs_u\n            for j in 1:i\n                Ke_uu[i,j] += 2 * mp.G * ∇Nu_sym_dev[i] ⊡ ∇Nu_sym_dev[j] * dΩ\n            end\n        end\n\n        for i in 1:n_basefuncs_p\n            δNp = shape_value(cellvalues_p, q_point, i)\n            for j in 1:n_basefuncs_u\n                divδNu = shape_divergence(cellvalues_u, q_point, j)\n                Ke_pu[i,j] += -δNp * divδNu * dΩ\n            end\n            for j in 1:i\n                Np = shape_value(cellvalues_p, q_point, j)\n                Ke_pp[i,j] += - 1/mp.K * δNp * Np * dΩ\n            end\n        end\n    end\n    symmetrize_lower!(Ke)\nend\n\nfunction symmetrize_lower!(K)\n    for i in 1:size(K,1)\n        for j in i+1:size(K,1)\n            K[i,j] = K[j,i]\n        end\n    end\nend;\n\nstruct PostProcessing\n    vtk_file::String\nend\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    dh = FP.getdh(p)\n    vtk_grid(post.vtk_file, dh) do vtkfile\n        vtk_point_data(vtkfile, dh, FP.getunknowns(p))\n    end\nend;\n\nfunction build_problem(ν, ip_u, ip_p)\n    def = create_definition(ν, ip_u, ip_p)\n    ip_u_string = isa(ip_u, Lagrange{2,RefTetrahedron,1}) ? \"linear\" : \"quadratic\"\n    post = PostProcessing(\"cook_$(ip_u_string)_linear\")\n    return FerriteProblem(def, post)\nend\n\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper([0.0,1.0]))\nν = 0.4999999\nlinear    = Lagrange{2,RefTetrahedron,1}()\nquadratic = Lagrange{2,RefTetrahedron,2}()\np1 = build_problem(ν, linear, linear)\np2 = build_problem(ν, quadratic, linear)\nsolve_problem!(solver, p1)\nsolve_problem!(solver, p2)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"","category":"page"},{"location":"examples/incompressible_elasticity/","page":"Incompressible Elasticity","title":"Incompressible Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FerriteProblems can be used to simplify the setup of this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteNeumann, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr()","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the material by including the definitions used in the original example, by using the J2Plasticity.jl file. We have modified the names and functions to comply with MaterialModelsBase.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This file defines the","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"J2Plasticity<:AbstractMaterial material type with the constructor J2Plasticity(E,ν,σy0,H)\nState variable struct J2PlasticityMaterialState<:AbstractMaterialState\nThe MaterialModelsBase function initial_material_state and material_response","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For a single material according to the MaterialModelsBase interface, the element is already included in FerriteProblems, see src/MaterialModelsBase.jl","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first create the problem's definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"traction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues (`Ferrite.jl`)\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions (`FerriteNeumann.jl`)\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states (using FerriteAssembly's `create_states`)\n    states = create_states(dh, x->initial_material_state(material), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For the problem at hand, we need to define the element routine, following FerriteAssemblys interface. This function is almost equivalent to the assemble_cell! in the original example, except that","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We don't have to reinit! as FerriteAssembly does that before calling\nThe traction is handled by FerriteNeumann and is not done for each cell","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"For convenience, this element is already implemented for materials of MaterialModelsBase type AbstractMaterial, and we don't need to define it here.","category":"page"},{"location":"examples/plasticity/#Setup-postprocessing","page":"Plasticity","title":"Setup postprocessing","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In contrast to the original example, we do not save directly to a vtk-file, but use FerriteProblem's IO features to save to JLD2 files. This has the advantage that further postprocessing can be done after the simulation, and we can then choose to export to the VTK-format or plot directly using e.g. FerriteViz.jl. We start by defining our custom postprocessing type.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With this postprocessing type, we can now define the postprocessing in FESolvers. Note that, internally, FerriteProblems imports the FESolvers functions getunknowns, getjacobian, and getresidual, such that you can access these via FerriteProblems. (or FP. if using the import FerriteProblems as FP above). For convenience, FerriteProblems will call FESolvers.postprocess! with the post as the first argument making it easy to dispatch on:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p)))\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We also define a helper function to plot the results after completion","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results. Here, we use FerriteProblems' safesolve that (1) creates our full problem::FerriteProblem and (2) ensures that files are closed even when the problem doesn't converge.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"global umax_solution = [0.0] # To save result for test #hide\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(solver, problem)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(solver, problem)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n    umax_solution[1] = problem.post.umag[end] # Save value for comparison  #hide\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(solver, problem)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\nusing Test # Compare to Ferrite.jl's example #hide\n@test isapprox(umax_solution[1], 0.254452; rtol=1.e-4);  #hide\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result when running display(plt)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Ferrite, Tensors, SparseArrays, LinearAlgebra\nusing FerriteProblems, FESolvers, FerriteNeumann, FerriteAssembly\nimport FerriteProblems as FP\nusing Plots; gr()\n\ninclude(\"J2Plasticity.jl\");\n\ntraction_function(time) = time*1.e7 # N/m²\n\nfunction setup_problem_definition()\n    # Define material properties (\"J2Plasticity.jl\" file)\n    material = J2Plasticity(200.0e9, 0.3, 200.e6, 10.0e9)\n\n    # Cell and facevalues (`Ferrite.jl`)\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    cv = CellVectorValues(QuadratureRule{3,RefTetrahedron}(2), interpolation)\n    fv = FaceVectorValues(QuadratureRule{2,RefTetrahedron}(3), interpolation)\n\n    # Grid and degrees of freedom (`Ferrite.jl`)\n    grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.,1.,1.)))\n    dh = DofHandler(grid); push!(dh, :u, 3, interpolation); close!(dh)\n\n    # Constraints (Dirichlet boundary conditions, `Ferrite.jl`)\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> zeros(3), [1, 2, 3]))\n    close!(ch)\n\n    # Neumann boundary conditions (`FerriteNeumann.jl`)\n    nh = NeumannHandler(dh)\n    add!(nh, Neumann(:u, fv, getfaceset(grid, \"right\"), (x,t,n)->Vec{3}((0.0, 0.0, traction_function(t)))))\n\n    # Initial material states (using FerriteAssembly's `create_states`)\n    states = create_states(dh, x->initial_material_state(material), cv)\n\n    return FEDefinition(;dh=dh, ch=ch, nh=nh, cv=cv, m=material, initialstate=states)\nend;\n\nstruct PlasticityPostProcess{T}\n    tmag::Vector{T}\n    umag::Vector{T}\nend\nPlasticityPostProcess() = PlasticityPostProcess(Float64[], Float64[]);\n\nfunction FESolvers.postprocess!(post::PlasticityPostProcess, p, step, solver)\n    # p::FerriteProblem\n    # First, we save some values directly in the `post` struct\n    push!(post.tmag, traction_function(FP.gettime(p)))\n    push!(post.umag, maximum(abs, FP.getunknowns(p)))\n\n    # Second, we save some results to file\n    # * We must always start by adding the next step.\n    FP.addstep!(p.io, p)\n    # * Save the dof values (only displacments in this case)\n    FP.savedofdata!(p.io, FP.getunknowns(p))\n    # * Save the state in each integration point\n    FP.saveipdata!(p.io, FP.getstate(p), \"state\")\nend;\n\nfunction plot_results(problem::FerriteProblem{<:PlasticityPostProcess};\n    plt=plot(), label=nothing, markershape=:auto, markersize=4\n    )\n    umax = vcat(0.0, problem.post.umag)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\n\nfunction example_solution()\n    def = setup_problem_definition()\n\n    # Fixed uniform time steps\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(solver, problem)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example, overwrite results by specifying the same folder\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"A\"))\n    solve_problem!(solver, problem)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping, save results to new folder\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    problem = FerriteProblem(def, PlasticityPostProcess(), joinpath(pwd(), \"B\"))\n    solve_problem!(solver, problem)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n\n    plot!(;legend=:bottomright)\n    return plt, problem, solver\nend;\n\nplt, problem, solver = example_solution();\n\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main types below are exported.  Remaining functions are not exported to avoid polluting the  name space. Tip: To simplify calling the following functions it is possible to write import FerriteProblems as FP as is done in the examples. ","category":"page"},{"location":"api/#Main-types","page":"API","title":"Main types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblem\nFEDefinition\nFerriteIO","category":"page"},{"location":"api/#FerriteProblems.FerriteProblem","page":"API","title":"FerriteProblems.FerriteProblem","text":"FerriteProblem(def::FEDefinition, post, buf::FEBuffer, io::[FerriteIO])\n\nThe main problem type that holds all variables to solve a particular problem  using FESolvers\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FEDefinition","page":"API","title":"FerriteProblems.FEDefinition","text":"FEDefinition(dh, ch, nh, cv, m, bl, initialstate, ic)\nFEDefinition(;dh, ch, cv, m,\n    nh=NeumannHandler(dh), bl=nothing,\n    initialstate=create_empty_states(dh,m),\n    ic=(),\n    )\n\nThe definition of the FE-problem, this data describes the finite  element problem as a function of time. For how long to run and how  to step through time is typically done by FESolvers.jl. \n\nFields/inputs\n\nSee more information below for items marked with *\n\ndh: The dof handler, Union{DofHandler,MixedDofHandler} (Ferrite.jl)\nch: The constraint handler, ConstraintHandler (Ferrite.jl)\nnh: The neumann bc handler, NeumannHandler (FerriteNeumann.jl)\ncv: The cellvalues, e.g. CellValues (*)\nm: The material definition, user defined type - passed into element. (*)\nbl: Source term/body load, user defined type - available from the element routine (*)\ninitialstate: The initial state variables for each cell in the grid,  can created by FerriteAssembly.create_states (*)\nic: Initial conditions. NamedTuple with a function f(x) for each field that  has a nonzero initial condition. Used by the initial_conditions! function.\ncc::ConvergenceCriterion: Determines how to calculate the convergence measure including scaling\n\nMixedDofHandler\n\nWhen the MixedDofHandler is used, we have an outer loop over each of its FieldHandlers. Therefore, cv, m, and bl may be provided for each of these fields by providing them as  a tuple. Otherwise, they are duplicated for each field (by reference)\n\ninitialstate must be a tuple containing Dict{Int} with states for the cells in the relevant  FieldHandler's cellset. \n\nMultiple CellValues for each element In coupled problems, each element might require multiple CellValues.  If the same should be used for all fields (even if only one FieldHandler),  a NamedTuple is the easiest (the alternative is a Tuple of Tuples).  If different multiple CellValues should be used for each field, then pass as  Tuple of NamedTuple/Tuple\n\nMultiple materials\n\nNote: The following setup is not needed if you have one material for each FieldHandler when using a MixedDofHandler\n\nIf you want to have different materials on different parts of the grid,  you should first define those cellsets, and then define each material  as a value of m::Dict{String} with the name of the cellset as key. \n\nYou may do the same for bl and cv.  Otherwise, the same values will be used for every cellset. \n\nCombine with MixedDofHandler:  Follow the required input for MixedDofHandler,  but wrap items (at least the material and initialstate) in Dicts as described above\n\nState variables:  initialstate::Dict{String} must mirror the datastructure of m::Dict{String}: For each key in m::Dict{String}, initialstate[key] holds a collection of states  for the cells in getcellset(dh,key).\n\nIf MixedDofHandler, then initialstate[key]::NTuple{N,<:Dict{Int}},  and if DofHandler, then initialstate[key]::Dict{Int}\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteProblems.FerriteIO","page":"API","title":"FerriteProblems.FerriteIO","text":"FerriteIO(\n    folder::String, def::FEDefinition, post=nothing; \n    def_file=\"FEDefinition.jld2\", \n    postfile=\"FEPost.jld2\",\n    T=Float64, \n    nsteps_per_file=typemax(Int), \n    switchsize=Inf\n    )\n\nConstructor for creating a FerriteIO when simulating. \n\n\n\n\n\nFerriteIO(filename::String)\n\nConstructor for reading a FerriteIO that was saved during a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.getdh\nFerriteProblems.getch\nFerriteProblems.getnh\nFerriteProblems.getcv\nFerriteProblems.getmaterial\nFerriteProblems.getbodyload\nFerriteProblems.getjacobian\nFerriteProblems.getunknowns\nFerriteProblems.getresidual\nFerriteProblems.getneumannforce\nFerriteProblems.getoldunknowns\nFerriteProblems.getstate\nFerriteProblems.getoldstate\nFerriteProblems.gettime\nFerriteProblems.getoldtime","category":"page"},{"location":"api/#FerriteProblems.getdh","page":"API","title":"FerriteProblems.getdh","text":"FP.getdh(p::FerriteProblem)\n\nGet dh::Ferrite.AbstractDofHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getch","page":"API","title":"FerriteProblems.getch","text":"FP.getch(p::FerriteProblem)\n\nGet the ConstraintHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnh","page":"API","title":"FerriteProblems.getnh","text":"FP.getnh(p::FerriteProblem)\n\nGet the NeumannHandler from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcv","page":"API","title":"FerriteProblems.getcv","text":"FP.getcv(p::FerriteProblem)\n\nGet the cell values from the FEDefinition.  Note that this could also be a Tuple or NamedTuple depending on  what was initially given to FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getmaterial","page":"API","title":"FerriteProblems.getmaterial","text":"FP.getmaterial(p::FerriteProblem)\n\nGet the material from the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getbodyload","page":"API","title":"FerriteProblems.getbodyload","text":"FP.getbodyload(p::FerriteProblem)\n\nGet the bodyload given to the FEDefinition\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getjacobian","page":"API","title":"FESolvers.getjacobian","text":"FP.getjacobian(p::FerriteProblem)\n\nGet the current jacobian matrix from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getjacobian\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getunknowns","page":"API","title":"FESolvers.getunknowns","text":"FP.getunknowns(p::FerriteProblem)\n\nGet the current vector of unknowns from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getunknowns\n\n\n\n\n\n","category":"function"},{"location":"api/#FESolvers.getresidual","page":"API","title":"FESolvers.getresidual","text":"FP.getresidual(p::FerriteProblem)\n\nGet the current residual vector from p.  Note that this function belongs to FESolvers.jl, but can be accessed via FP.getresidual\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getneumannforce","page":"API","title":"FerriteProblems.getneumannforce","text":"FP.getneumannforce(p::FerriteProblem)\n\nGet the current external force vector caused by  Neumann boundary conditions. Note that this vector  does not include external forces added during the  cell assembly; only forces added with the NeumannHandler\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldunknowns","page":"API","title":"FerriteProblems.getoldunknowns","text":"FP.getoldunknowns(p::FerriteProblem)\n\nGet the vector of unknowns from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getstate","page":"API","title":"FerriteProblems.getstate","text":"FP.getstate(p::FerriteProblem)\n\nGet the current state variables\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldstate","page":"API","title":"FerriteProblems.getoldstate","text":"FP.getoldstate(p::FerriteProblem)\n\nGet the state variables from the previously converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettime","page":"API","title":"FerriteProblems.gettime","text":"FP.gettime(p::FerriteProblem)\n\nGet the current time\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getoldtime","page":"API","title":"FerriteProblems.getoldtime","text":"FP.getoldtime(p::FerriteProblem)\n\nGet time of the previous converged step\n\n\n\n\n\n","category":"function"},{"location":"api/#Special-cases","page":"API","title":"Special cases","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FerriteProblems.allocate_material_cache","category":"page"},{"location":"api/#FerriteProblems.allocate_material_cache","page":"API","title":"FerriteProblems.allocate_material_cache","text":"FP.allocate_material_cache(material)\n\nIn case the material requires a cache to be available during the element routine, this function can be overloaded for the specific material to define such a cache to be included in the FerriteAssembly.CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#Saving-and-loading-data","page":"API","title":"Saving and loading data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FESolvers.postprocess!\nFerriteProblems.close_postprocessing\nFerriteProblems.addstep!\nFerriteProblems.gettimedata\nFerriteProblems.savedofdata!\nFerriteProblems.getdofdata\nFerriteProblems.savenodedata!\nFerriteProblems.getnodedata\nFerriteProblems.savecelldata!\nFerriteProblems.getcelldata\nFerriteProblems.saveipdata!\nFerriteProblems.getipdata\nFerriteProblems.saveglobaldata!\nFerriteProblems.getglobaldata\nFerriteProblems.getdef\nFerriteProblems.getpost","category":"page"},{"location":"api/#FESolvers.postprocess!","page":"API","title":"FESolvers.postprocess!","text":"FESolvers.postprocess!(p::FerriteProblem, step, solver)\n\nWhen FESolvers call this function for p::FerriteProblem,  the following function\n\nFESolvers.postprocess!(post, p::FerriteProblem, step, solver)\n\nis called where post=p.post (unless you define a different override).  This allows you to easily define the dispatch on your postprocessing  type as FESolvers.postprocess!(post::MyPostType, p, step, solver)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.close_postprocessing","page":"API","title":"FerriteProblems.close_postprocessing","text":"close_postprocessing(post::MyPostType, p::FerriteProblem)\n\nThis function is called to close any open files manually created during  the postprocessing with the custom postprocessing type MyPostType.  Note that the file streams in p.io::FerriteIO are  automatically closed and don't require any special handling.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.addstep!","page":"API","title":"FerriteProblems.addstep!","text":"FP.addstep!(io::FerriteIO, p::FerriteProblem)\n\nAdd a new step to be saved by io at the time gettime(p) Must be called before adding any new data\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.gettimedata","page":"API","title":"FerriteProblems.gettimedata","text":"gettimedata(io::FerriteIO)\ngettimedata(io::FerriteIO, step)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savedofdata!","page":"API","title":"FerriteProblems.savedofdata!","text":"FP.savedofdata!(io::FerriteIO, vals, dt_order=0, field=\"dof\")\n\nSave data pertaining to each degree of freedom. Use a different field than \"dof\"` to save data located at each dof,  but not the actual dof values (e.g. the residual vector)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdofdata","page":"API","title":"FerriteProblems.getdofdata","text":"FP.getdofdata(io::FerriteIO, step, field=\"dof\"; dt_order=0)\n\nGet the data saved by savedofdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savenodedata!","page":"API","title":"FerriteProblems.savenodedata!","text":"FP.savenodedata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data located at each node. By convention this should be indexed by the node numbers in the grid. (E.g. a Vector for all nodes or a Dict{Int} with keys the node numbers)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getnodedata","page":"API","title":"FerriteProblems.getnodedata","text":"FP.getnodedata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by savenodedata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.savecelldata!","page":"API","title":"FerriteProblems.savecelldata!","text":"FP.savecelldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each cell.  By convention this should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getcelldata","page":"API","title":"FerriteProblems.getcelldata","text":"FP.getcelldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by savecelldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveipdata!","page":"API","title":"FerriteProblems.saveipdata!","text":"FP.saveipdata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data for each integration point in cells in the grid.  By convention the data for each cell should be indexed by the cell numbers in the grid. (E.g. a Vector for all cells or a Dict{Int} with keys the cell indices) Note that it is on the user to know how the integration points are numbered,  i.e. which QuadratureRule that was used. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getipdata","page":"API","title":"FerriteProblems.getipdata","text":"FP.getipdata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by saveipdata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.saveglobaldata!","page":"API","title":"FerriteProblems.saveglobaldata!","text":"FP.saveglobaldata!(io::FerriteIO, vals, field, dt_order=0)\n\nSave data that is global to the entire simulation, i.e. global quantites such as  reaction forces, total dissipation, etc. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getglobaldata","page":"API","title":"FerriteProblems.getglobaldata","text":"FP.getglobaldata(io::FerriteIO, step, field; dt_order=0)\n\nGet the data saved by saveglobaldata! in step for field.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getdef","page":"API","title":"FerriteProblems.getdef","text":"FP.getdef(io::FerriteIO)\n\nLoad the FEDefinition from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteProblems.getpost","page":"API","title":"FerriteProblems.getpost","text":"FP.getpost(io::FerriteIO)\n\nLoad the user defined post from the results saved by io\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteProblems","category":"page"},{"location":"#FerriteProblems","page":"Home","title":"FerriteProblems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FerriteProblems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When using the FESolvers.jl package together with Ferrite.jl,  the user has to specify a problem to be solved.  The purpose of FESolvers.jl is to keep this as general as possible,  and not require users to structure their problem structs in a certain way. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package brings together the  FESolvers.jl package with  Ferrite.jl, as well as the supporting packages  FerriteAssembly.jl and  FerriteNeumann.jl.  There is also extensive support for organizing your simulations  by saving both setup and results as .jld2 using JLD2.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"All unregistered dependencies, including FerriteProblems.jl itself,  is available in the knutamregistry","category":"page"},{"location":"","page":"Home","title":"Home","text":"The workflow requires you to create its FerriteProblem type which  can then be solved by FESolvers.jl.  The easiest way to get started is to just follow the examples.  Note that the documentation of Ferrite.jl, FerriteAssembly.jl,  and FerriteNeumann.jl should be considered as well. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct FerriteProblem{POST,DEF,BUF,IOT}\n    def::DEF\n    post::POST\n    buf::BUF\n    io::IOT\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"with FerriteProblem(def, post=nothing, io=nothing) as constructor.  The four parts have distinct tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"def::FEDefinition is responsible for the full problem definition.  I.e., given def, the full simulation should be possible to replicate,  given the same solver from FESolvers.jl\npost contains all information related to the postprocessing of each step.  This typically varies a lot between simulations,  and is the first type parameter to allow easy  dispatch on problems with different posts.  \nbuf::FEBuffer contains all buffer values,  these are not necessary (nor desirable) to save,  and can be recreated each time the constructor is called.\nio::FerriteIO: This field enable file handling to allow easy saving  and retrieving of results from a simulation using JLD2 files.","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note: These functions are not considered \"documented\" and changes here are therefore not considered breaking.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteProblems.FEBuffer\nFerriteProblems.getcellbuffer\nFerriteProblems.update_unknowns!\nFerriteProblems.copy_states!\nFerriteProblems.update_states!\nFerriteProblems.reset_states!\nFerriteProblems.settime!\nFerriteProblems.update_time!\nFerriteProblems.create_empty_states\nFerriteProblems.filepath\nFerriteProblems.datafilepath\nFerriteProblems.new_file!\nFerriteProblems.new_file_if_needed!\nFerriteProblems.update_currentsize!\nFerriteProblems.getfilenumber\nFerriteProblems.open_if_needed!\nFerriteProblems.checkkey\nFerriteProblems.savedata!\nFerriteProblems.getdata\nFerriteProblems.get_dof2node\nFerriteProblems.initial_conditions!","category":"page"},{"location":"internals/#FerriteProblems.FEBuffer","page":"Internals","title":"FerriteProblems.FEBuffer","text":"FEBuffer(K,x,r,f,xold,cellbuffer,state,old_state,time,old_time)\n\nA buffer to hold all values that are required to simulate,  but that are uniqely defined from the simulation definition\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteProblems.getcellbuffer","page":"Internals","title":"FerriteProblems.getcellbuffer","text":"FP.getcellbuffer(p::FerriteProblem)\n\nGet the cell buffers used during the assembly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_unknowns!","page":"Internals","title":"FerriteProblems.update_unknowns!","text":"FP.update_unknowns!(p::FerriteProblem)\n\nUpdate the vector of \"old\" unknowns to the values of the current vector of unknowns\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.copy_states!","page":"Internals","title":"FerriteProblems.copy_states!","text":"FP.copy_states!(to, from)\n\nPerform a \"deepcopy!\" of states in from into to.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_states!","page":"Internals","title":"FerriteProblems.update_states!","text":"FP.update_states!(p::FerriteProblem)\n\nUpdate the \"old\" state variables to the current values. Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.reset_states!","page":"Internals","title":"FerriteProblems.reset_states!","text":"FP.reset_states!(p::FerriteProblem)\n\nReset the current state variables to the old state values.  Called after each solution iteration unless the solution has converged. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.settime!","page":"Internals","title":"FerriteProblems.settime!","text":"FP.settime!(p::FerriteProblem, new_time)\n\nSet the current time to new_time Called when starting a new step (or when attempting the same  step number with a new time increment)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_time!","page":"Internals","title":"FerriteProblems.update_time!","text":"FP.update_time!(p::FerriteProblem)\n\nUpdate the old time to the current time.  Called after convergence\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.create_empty_states","page":"Internals","title":"FerriteProblems.create_empty_states","text":"FP.create_empty_states(dh, material)\n\nUsed to create empty states in case state variables aren't used in the simulation by calling FerriteAssembly.create_states without any input (returning nothing for each cell)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.filepath","page":"Internals","title":"FerriteProblems.filepath","text":"filepath(io::FerriteIO, args...) = joinpath(io.folder[], args...)\n\nGet the path of a file relative io's folder\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.datafilepath","page":"Internals","title":"FerriteProblems.datafilepath","text":"datafilepath(io::FerriteIO, num=length(io.datafiles))\n\nGet the path of the data file number num in io.datafiles\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file!","page":"Internals","title":"FerriteProblems.new_file!","text":"new_file!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.new_file_if_needed!","page":"Internals","title":"FerriteProblems.new_file_if_needed!","text":"new_file_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.update_currentsize!","page":"Internals","title":"FerriteProblems.update_currentsize!","text":"update_currentsize!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getfilenumber","page":"Internals","title":"FerriteProblems.getfilenumber","text":"getfilenumber\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.open_if_needed!","page":"Internals","title":"FerriteProblems.open_if_needed!","text":"open_if_needed!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.checkkey","page":"Internals","title":"FerriteProblems.checkkey","text":"checkkey\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.savedata!","page":"Internals","title":"FerriteProblems.savedata!","text":"savedata!\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.getdata","page":"Internals","title":"FerriteProblems.getdata","text":"getdata\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.get_dof2node","page":"Internals","title":"FerriteProblems.get_dof2node","text":"get_dof2node\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteProblems.initial_conditions!","page":"Internals","title":"FerriteProblems.initial_conditions!","text":"initial_conditions!(\n    a::AbstractVector, dh::DofHandler, field::Symbol, f::Function, \n    cellset=1:getncells(dh.grid),\n    ip_geo=_default_interpolation(dh)\n    )\n\nApply initial conditions using the function f\n\n\n\n\n\n","category":"function"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"EditURL = \"https://github.com/KnutAM/FerriteProblems.jl/blob/main/docs/src/literate/transient_heat.jl\"","category":"page"},{"location":"examples/transient_heat/#Linear-Time-Dependent-Problem","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This example is the same example as FESolvers.jl's transient heat flow which was taken from Ferrite.jl's transient heat flow. Please see the theoretical derivations in those examples, with the specific formulation used here in the former.","category":"page"},{"location":"examples/transient_heat/#Commented-Program","page":"Linear Time Dependent Problem","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Now we solve the problem by using FerriteProblems. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First we load required packages","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP","category":"page"},{"location":"examples/transient_heat/#Physics","page":"Linear Time Dependent Problem","title":"Physics","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First, we need to define the material behavior.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Base.@kwdef struct FicksLaw{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"where we could have defined the heat source using the bodyload type available via the cellbuffer, but it is not necessary for a constant heat source.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define element routine following FerriteAssembly","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FicksLaw, cellvalues, dh_fh, Δt, buffer\n    )\n    ue_old = buffer.ae_old  # Extract old values from the CellBuffer (TODO: Perhaps good to have get-functions for this)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We start by a function that will create the problem definition","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, cv=cellvalues, m=FicksLaw())\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#Postprocessing","page":"Linear Time Dependent Problem","title":"Postprocessing","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"After defining all the physics and problem setup, we must decide what data to save. In this example, we use the vtk-file exports as in the original example. To this end, we define the custom postprocessing struct","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And the postprocessing function that is called after each time step","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    @info \"postprocessing step $step\"\n    dh = FP.getdh(p)\n    vtk_grid(\"transient-heat-$step\", dh) do vtk\n        vtk_point_data(vtk, dh, FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"At the end of the simulation, we want to finish all IO operations. We can then define the function close_postprocessing which will be called even in the case that an error is thrown during the simulation","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FP.close_postprocessing(post::PostProcessing, p)\n    vtk_save(post.pvd)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And now we create the problem type, and define the QuasiStaticSolver with the LinearProblemSolver as well as fixed time steps","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"def = create_definition()\npost = PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Finally, we can solve the problem","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"solve_problem!(solver, problem);\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#transient_heat_equation-plain-program","page":"Linear Time Dependent Problem","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat.jl.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, FerriteProblems, FerriteAssembly, FESolvers\nimport FerriteProblems as FP\n\nBase.@kwdef struct FicksLaw{T}\n    k::T=1.0e-3    # Thermal conductivity\n    f::T=5.0e-1    # Constant heat source\nend\n\nfunction FerriteAssembly.element_routine!(\n    Ke, re, state, ue, m::FicksLaw, cellvalues, dh_fh, Δt, buffer\n    )\n    ue_old = buffer.ae_old  # Extract old values from the CellBuffer (TODO: Perhaps good to have get-functions for this)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * m.f) + Δt * m.k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * m.k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\n\nfunction create_definition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    cellvalues = CellScalarValues(\n        QuadratureRule{2, RefCube}(2),\n        Lagrange{2, RefCube, 1}());\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid); push!(dh, :u, 1); close!(dh)\n\n    # **Boundary conditions**\n    # Zero pressure on $\\partial \\Omega_1$ and linear ramp followed by constant pressure on $\\partial \\Omega_2$\n    max_temp = 100; t_rise = 100\n    ch = ConstraintHandler(dh);\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₁, (x, t) -> 0));\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    add!(ch, Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1)))\n    close!(ch)\n\n    # Create and return the `FEDefinition`\n    return FEDefinition(;dh=dh, ch=ch, cv=cellvalues, m=FicksLaw())\nend;\n\nstruct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(post::PostProcessing, p, step, solver)\n    @info \"postprocessing step $step\"\n    dh = FP.getdh(p)\n    vtk_grid(\"transient-heat-$step\", dh) do vtk\n        vtk_point_data(vtk, dh, FP.getunknowns(p))\n        vtk_save(vtk)\n        post.pvd[step] = vtk\n    end\nend;\n\nfunction FP.close_postprocessing(post::PostProcessing, p)\n    vtk_save(post.pvd)\nend;\n\ndef = create_definition()\npost = PostProcessing()\nproblem = FerriteProblem(def, post)\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\n\nsolve_problem!(solver, problem);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
